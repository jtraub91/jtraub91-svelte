<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../favicon.jpg" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="../_app/immutable/assets/0.DPidJByt.css" rel="stylesheet">
		<link href="../_app/immutable/assets/4.cuQNAo3a.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.CQlWdkbR.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/entry.8MVA_tgp.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/runtime.DloJ9bwY.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/paths.Bxc1DnSU.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index-client.oE4o-9y1.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.VedFBwoq.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/render.U6tP9mdC.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/disclose-version.D5aYQnBI.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/props.Dd9MefIC.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/store.CwMe1Djl.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0._fOR5UMK.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/legacy.CyhzUJuU.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/attributes.DvgAUZjV.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/lifecycle.BfUUx4s0.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/4.q1bs1AoR.js">
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><div class="flex flex-col min-w-[420px]"><header class="flex flex-row"><div class="top-0 left-0 h-20 w-20 min-h-20 min-w-20"><a href="../" id="yoshi-github-jtraub91" class="svelte-dpys7o"><img src="../images/yoshi-github-jtraub91.jpg" alt="yoshi-github-jtraub91"></a></div> <a href="../blog" class="nav-link mx-2 mt-auto mb-0 font-mono text-lg text-[dodgerblue] hover:text-[indigo]  svelte-dpys7o">blog</a> <a href="../links" class="nav-link mx-2 mt-auto mb-0 font-mono text-lg text-[dodgerblue] hover:text-[indigo]  svelte-dpys7o"><span class="mb-0 mt-auto mx-auto">links</span></a></header><!----> <div class="flex flex-col"><!----><div class="flex flex-col"><h1 class="text-center svelte-1azcsk6">Introducing bits</h1> <div class="text-center text-sm text-gray-500">May 1, 2023</div> <article class="svelte-1azcsk6"><!----><p>Introducing <a href="https://github.com/jtraub91/bits">bits</a>, a free and open source cli tool and pure Python library developed for Bitcoin.</p>
<p>This post will serve as informal documentation for some of what you can do with <a href="https://github.com/jtraub91/bits">bits</a> today, and what is planned for the future.</p>
<h2>Installation</h2>
<pre><code class="language-bash">git clone https://github.com/jtraub91/bits
cd bits/
pip install .
</code></pre>
<h2>Usage</h2>
<p><a href="https://github.com/jtraub91/bits">bits</a> is pure Python, and thus, can be used as a library by calling its various functions and methods directly (with documentation coming soon üöÄ); however, often it&#39;s convenient to simply use a command line interface (CLI) to common functionality. The <a href="https://github.com/jtraub91/bits">bits</a> CLI provides many different methods which are explained in detail in the subsequent sections.</p>
<h2>Command Line Interface</h2>
<h3>The <code>bits</code> base command</h3>
<p>The <code>bits</code> command, by itself, with no subcommand present, is a command in its own rite which will &quot;convert input bits to bytes&quot;.</p>
<p>To elaborate, three input / output (I/O) formats are supported: raw bytes, binary string, and hexadecimal string, which may be specified independently making <code>bits</code> able to be used as a converter between these formats. Raw bytes are read transparently; however, binary string and hexadecimal string input is stripped of leading or trailing whitespace, <em>and</em> left zero padded to the nearest byte if not provided as an integer multiple of 8 bits. Furthermore, raw bytes are output as-is, yet binary and hexadecimal string will be output will have a trailing newline character.</p>
<h4>Comparing to <code>xxd</code></h4>
<p>The <code>bits</code> base command, sharing functionality with standard Linux utility <a href="https://linux.die.net/man/1/xxd">xxd</a>, can be used similarly in some respects.</p>
<p>With <code>xxd</code>, we can convert a raw binary input to a hex string like so,</p>
<pre><code class="language-bash">head -c 8 /dev/urandom | xxd -p
</code></pre>
<p>Similarly we can do the following with <code>bits</code></p>
<pre><code class="language-bash">head -c 8 /dev/urandom | bits -1 -0x
</code></pre>
<p>The <code>-1</code> indicates that the <em>input</em> is raw bytes, while the <code>-0x</code> flag indicates the <em>output</em> shall be a hexadecimal string. In general, these flags can be ommitted, but unless otherwise <a href="https://github.com/jtraub91/bits#configuration">configured</a>, the default I/O format for most commands is hexadecimal string.</p>
<p>The <code>bits</code> command will output the string on a single line, whereas with <code>xxd</code> we may have to use the <code>-c</code> argument to achieve a similar result. For example,</p>
<pre><code class="language-bash">head -c 32 /dev/urandom | xxd -p -c 32
</code></pre>
<p>becomes simply</p>
<pre><code class="language-bash">head -c 32 /dev/urandom | bits -1 
</code></pre>
<p>(As alluded to above, with <code>-0x</code> omitted, and no other configuration, the output format defaults to hexadecimal string)</p>
<p>Furthermore, the support for binary strings provides functionality that <code>xxd</code> does not (nor any other CLI tool that I am aware of), in that it can convert between binary string representation. For example, with <code>xxd</code> in <code>-bits</code> (<code>-b</code>) mode, we can do,</p>
<pre><code class="language-bash">head -c 32 /dev/urandom | xxd -b
</code></pre>
<p>to get a binary string representation of the input; but it outputs it in octets, which may be inconvenient for further processing. Furthermore, the <code>-revert</code> (<code>-r</code>) flag &quot;[does] not work with [<code>-bits</code>] mode&quot;. <a href="#citations">[1]</a></p>
<p>So with <code>xxd</code> we can convert raw bytes to a hexadecimal string, and revert.</p>
<pre><code class="language-bash">head -c 32 /dev/urandom | xxd -p -c 32 | xxd -r -p
</code></pre>
<p>But, we cannot do the same with <code>-b</code></p>
<pre><code class="language-bash">head -c 32 /dev/urandom | xxd -b | xxd -r -b
xxd: sorry, cannot revert this type of hexdump
</code></pre>
<p>But, we can with <code>bits</code></p>
<pre><code class="language-bash">head -c 32 /dev/urandom | bits -1 -0b | bits -1b -0
</code></pre>
<h3>CLI subcommands</h3>
<p>Now, let&#39;s get into some of the more useful and specific Bitcoin functions that <code>bits</code> provides. These are provided by various <em>subcommands</em>. You can view a full list of available subcommands with</p>
<pre><code class="language-bash">bits -h
</code></pre>
<p>Subcommand specific help is also available with</p>
<pre><code class="language-bash">bits &lt;subcommand&gt; -h
</code></pre>
<h3>Generate a Bitcoin private key</h3>
<p>The <code>bits key</code> command will generate a bitcoin private key, which is nothing but a 256 bit random value strictly less than <code>SECP256K1_N</code>. <a href="#citations">[2]</a></p>
<p>This, you may notice, <em>can</em> be generated with the base command, e.g.</p>
<pre><code class="language-bash">head -c 32 /dev/urandom | bits -1
</code></pre>
<p>but instead of having to manually confirm the output is below <code>SECP256K1_N</code> you can use <code>bits key</code> instead for convenience.</p>
<p>Also, note that if a command has input or output, it will accept an <code>--input-file</code> (<code>-in</code>, <code>-i</code>) and/or <code>--out-file</code> (<code>-out</code>, <code>-o</code>) optional argument, defaulting to stdin or stdout, respectively. (Also, as applicable, a command with input or output will usually include the input and output format flags illustrated above for the <a href="#the-bits-base-command">bits base command</a>). Thus, to conceal the private key from being exposed on the command line, you may use the following command, for example.</p>
<pre><code class="language-bash">bits key -out secret.hex
</code></pre>
<p>(or standard shell redirection, e.g. <code>bits key &gt; secret.hex</code>)</p>
<p>For compatibility with legacy tooling (if you&#39;re into that sort of thing), the <code>bits key</code> command supports PEM-encoded private key output, e.g.</p>
<pre><code class="language-bash">bits key -0pem
</code></pre>
<p>Note that <code>bits</code> <em>does not</em> currently provide support for PEM-encoded <em>input</em> on the CLI, so you will need to convert back to a supported format (raw, bin, hex) in order to use with other <code>bits</code> (sub)commands. This can be done with <a href="https://www.openssl.org/">openssl</a> (<code>openssl ec</code> or <code>openssl asn1parse</code>, for example).</p>
<h3>Create a public key from a private key</h3>
<p>The <code>bits pubkey</code> command generates a public key (pubkey) from a private key. E.g.</p>
<pre><code class="language-bash">bits pubkey -in secret.hex
</code></pre>
<p>You may output a compressed pubkey with the <code>--compressed</code> (<code>-X</code>) flag.</p>
<pre><code class="language-bash">bits pubkey -in secret.hex -X -out pubkey.hex
</code></pre>
<p>Notice we leverage the <code>-out</code> flag again above to save the pubkey to a file.</p>
<h3>Creating a bitcoin address</h3>
<p>Now, you may want to create a Bitcoin address from your key pair. The <code>bits addr</code> command provides a convenient method to handle the encoding for various address types. This command supports generating legacy and segwit addresses alike, but expects the payload to passed in as the argument. For example, for legacy <a href="https://learnmeabitcoin.com/technical/p2pkh">pay to pubkey hash</a> addresses (P2PKH), we&#39;ll need to hash the pubkey first with <code>hash160</code>. The <a href="https://github.com/jtraub91/bits">bits</a> CLI fortunately provides the <code>ripemd160</code>, <code>sha256</code>, <code>hash160</code>, and <code>hash256</code> crypto hashing subcommands for convenience. Thus, to generate a legacy Bitcoin address from our pubkey, we may use the following, for example.</p>
<pre><code class="language-bash">bits hash160 -in pubkey.hex | bits addr | awk &#39;{print $1}&#39;
</code></pre>
<p>In the above example, the pubkey saved to <code>pubkey.hex</code> is read as input to <code>bits hash160</code>, thus is hashed, and piped to the <code>bits addr</code> command to complete the encoding. The output of <code>bits addr</code> is then piped into <code>awk</code> only for readability, i.e. to produce a newline on the shell output since <code>bits addr</code> will technically output raw binary, with no newline appended; however, in these situations <code>bits</code> provides the <code>--print</code> (<code>-P</code>) flag to do the same, for convenience. E.g.</p>
<pre><code class="language-bash">bits hash160 -in pubkey.hex | bits addr -P
</code></pre>
<p>The <code>bits addr</code> command accepts a <code>--type</code> (<code>-T</code>) flag for address type which defaults to &quot;p2pkh&quot; for P2PKH addresses, but may be specified to be &quot;p2sh&quot; for <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP16</a> <a href="https://learnmeabitcoin.com/technical/p2sh">pay to script hash</a> (P2SH) addresses.</p>
<p>A testnet address may be generated instead by leveraging the <code>--network</code> (<code>-N</code>) flag. E.g.</p>
<pre><code class="language-bash">bits hash160 -in pubkey.hex | bits addr -N testnet -P
</code></pre>
<p>Segwit addresses can be generated similarly, e.g.</p>
<pre><code class="language-bash">bits hash160 -in pubkey.hex | bits addr --witness-version 0 -P
</code></pre>
<p>The presence of the <code>--witness-version</code> (<code>--wv</code>) flag indicates a segwit address and its value represents the version. When this flag is present the <code>--type</code> flag is ignored. Segwit addresses, per <a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki">BIP 141</a>, identify themselves as <a href="https://river.com/learn/terms/p/p2wpkh/">pay to witness key hash</a> (P2WKH) or <a href="https://river.com/learn/terms/p/p2wsh/">pay to witness script hash</a> (P2WSH) by the size of their payload, thus the user is expected to form and provide the correct payload as necessary.</p>
<p>The <code>bits addr</code> command isn&#39;t doing anything magical üßô‚Äç‚ôÇÔ∏è It accepts a payload and optional network and address type (or witness version) arguments, prepends the correct version byte and encodes in <a href="https://en.bitcoin.it/wiki/Base58Check_encoding">base58check</a> or <a href="https://en.bitcoin.it/wiki/Bech32">bech32</a> (<a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">BIP 173</a>), as appropriate. This can also be done manually with other <a href="https://github.com/jtraub91/bits">bits</a> CLI subcommands as we will see in the next section.</p>
<h3>Encoding (and decoding) with <code>base58</code> and <code>bech32</code></h3>
<p>The <a href="https://github.com/jtraub91/bits">bits</a> CLI provides methods for encoding and decoding base58(check) and bech32.</p>
<p>Recreating what was performed above by the <code>bits addr</code> command, but instead with <code>bits base58</code> and <code>bits bech32</code>, repectively, we could do the following, for example.</p>
<p>For legacy P2PKH addresses:</p>
<ul>
<li>Take your pubkey and hash it like before</li>
<li>Pre-prend the version byte (<code>0x00</code> for mainnet)</li>
<li>Encode with <a href="https://en.bitcoin.it/wiki/Base58Check_encoding">base58check</a></li>
</ul>
<p>Doing this, all at once, on the command line, would look something like the following.</p>
<pre><code class="language-bash">bits hash160 -in pubkey.hex | awk &#39;{print &quot;00&quot;$1}&#39; | bits base58 --check
</code></pre>
<p>The <code>--check</code> option is supplied so that the checksum is appended. The <code>bits base58</code> command also supports a <code>--decode</code> option for retrieving the original payload, e.g.</p>
<pre><code class="language-bash">echo -n &lt;base58-check-encoded-address&gt; | bits base58 --check --decode
</code></pre>
<p>The <code>--check</code> flag with the <code>--decode</code> flag present will make <code>bits</code> ensure that the checksum is valid.</p>
<p>Similarly, we can reproduce segwit address we previously created with <code>bits addr</code>, instead with <code>bits bech32</code>.</p>
<pre><code class="language-bash">bits hash160 -in pubkey.hex | bits bech32 --hrp bc --wv 0 -P
</code></pre>
<p>As we can see, the <code>bits bech32</code> command gives us a little bit more flexibility with regard to the <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32">bech32 specification</a>, whereas <code>bits addr</code> provides practical convenience. With <code>bits bech32</code> we can supply an arbitrary human readable part via <code>--hrp</code> and an optional Segwit version via the <code>--witness-version</code> (<code>--wv</code>) flag. From there, the data passed as input is encoded, with checksum appended. Alternatively, the <code>bits addr</code> command provides convenience by performing the address encoding as inferred from the options provided, i.e. <code>--network</code> (<code>-N</code>), <code>--type</code> (<code>-T</code>), and <code>--witness-version</code> (<code>--wv</code>).</p>
<p>Furthermore, we can also <em>decode</em> bech32, e.g.</p>
<pre><code class="language-bash">echo -n &lt;bech32-encoded&gt; | bits bech32 --decode
</code></pre>
<p>The output of the previous commnd is a JSON string. If input is determined to be a segwit address, the output will have the keys &quot;network&quot;, &quot;witness_version&quot;, and &quot;witness_program&quot;; otherwise the keys will be &quot;hrp&quot; and &quot;payload&quot;.</p>
<h3>Mnemonic seeds and HD wallet operations</h3>
<p><code>bits</code> provides two subcommands for mnemonic / seed generation and hierarchical deterministic wallets per <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a>, <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a>, <a href="https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki">BIP43</a>, and <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a>: <code>bits mnemonic</code> and <code>bits hd</code>.</p>
<p>To generate a mnemonic seed phrase you may simply use the following.</p>
<pre><code class="language-bash">bits mnemonic
</code></pre>
<p>This command also supports providing your own entropy. For example,</p>
<pre><code class="language-bash">head -c 32 /dev/urandom | bits mnemonic -1 --from-entropy
</code></pre>
<p>Furthermore, we can provide the generated mnemonic as input to the <code>bits mnemonic</code> command, with the <code>--to-seed</code> or <code>--to-master-key</code> options present to generate the seed or master key (per <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#master-key-generation">BIP 32</a>), respectively. These options will cause <code>bits mnemonic</code> to prompt for a passphrase at the CLI (which can be blank).</p>
<pre><code class="language-bash">echo &lt;mnemonic-phrase&gt; | bits mnemonic --to-master-key
passphrase: 
</code></pre>
<p>The base58check-encoded master key, provided as output of the previous command, is needed for further derivation with the <code>bits hd</code> command.</p>
<p>With <code>bits hd</code> you may derive private extended private keys (xprv) or extended public keys (xpub) by supplying the root key and a derivation path per <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a>, <a href="https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki">BIP43</a>, and/or <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a>. For example,</p>
<pre><code class="language-bash">echo -n &lt;root-key&gt; | bits hd &quot;m/44&#39;/0&#39;/0&#39;/0/0&quot;
</code></pre>
<p>The leading <code>m</code> indicates private key derivation, implying that a xprv must be supplied as input. The command will then derive and return the xprv at the derivation path provided, <em>but</em> the xpub can be returned instead by supplying the <code>--xpub</code> flag. E.g.</p>
<pre><code class="language-bash">echo -n &lt;root-key&gt; | bits hd &quot;m/44&#39;/0&#39;/0&#39;/0/0&quot; --xpub
</code></pre>
<p>Also, a deserialized key can be emitted to stderr as a JSON string (with keys &quot;version&quot;, &quot;depth&quot;, &quot;parent_key_fingerprint&quot;, &quot;child_no&quot;, and &quot;key&quot;) by supplying the optional <code>--dump</code> flag.</p>
<p>Public derivation is supported and can be used by indicating a capital <code>M</code> in the derivation path. E.g.</p>
<pre><code class="language-bash">echo -n &lt;xpub&gt; | bits hd &quot;M/0&quot; 
</code></pre>
<p>Also, of note, is that you aren&#39;t required to use the <em>root</em> master key as input for the derivation. Any derived key can be used as the starting point, and derivation will happen relative to it. This may be useful in practice, so as to not expose the root master key on the same machine that derivation is performed.</p>
<h3>Leveraging a Bitcoin Core Node</h3>
<p>So far we&#39;ve seen that the <a href="https://github.com/jtraub91/bits">bits</a> CLI is able to do some basic bits to bytes manipulations and provide some utilites for generating and managing Bitcoin keys, addresses, and whatnot. What <a href="https://github.com/jtraub91/bits">bits</a> <em>does not</em> do, currently, is provide a full node for consensus. For now, I recommend having a local <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> node running (i.e. <code>bitcoind</code>) so that blockchain data can be downloaded, transactions can be relayed, and a node for verifying and maintaining consensus can be employed, strengthening the Bitcoin network.</p>
<p>Part of the plan for <a href="https://github.com/jtraub91/bits">bits</a> is to implement a full node, with built-in <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a> server, by version 1. There does actually exist code in the codebase that has started to implement such, but it is not currently very functional nor supported.</p>
<p>So in the meantime, I recommend leveraging <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> here. As we continue thru this blog, you may want a <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> node while using subcommands such as <code>bits tx</code>, for looking up necessary blockchain data, but additionally and moreover, <code>bits</code> can be configured to directly interact with <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> over RPC, either by sending raw RPC commands via the <code>bits rpc</code> command, or by leveraging it internally, as with the <code>bits send</code> command, for example. These will be explained, in detail, in the following sections.</p>
<p>To download a <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> binary for installation on your OS, see <a href="https://bitcoincore.org/en/download/">downloads</a>.</p>
<h3>Configuring <code>bits</code> with a local Bitcoin Core node</h3>
<p>Nominal bits configuration is located in your user&#39;s home directory, in a directory named <code>.bits</code>, in a file named either <code>config.toml</code> or <code>config.json</code>, depending on <a href="https://github.com/jtraub91/bits#config-file-support">config file support</a>.</p>
<p>You may configure a connection via RPC with either cookie based authentication or a user &amp; password. To connect via cookie based authentication, all you should configure is <code>rpc_url</code> and <code>rpc_datadir</code>. These may be specified at the CLI for dependent subcommands, or configured in <code>~/.bits/config.toml</code>, for example.</p>
<p>For cookie based auth,</p>
<pre><code class="language-toml">rpc_url=&quot;http://localhost:8332&quot;
rpc_datadir=&quot;~/.bitcoin&quot;
</code></pre>
<p>Or for rpc user / password,</p>
<pre><code class="language-toml">rpc_url=&quot;http://localhost:8332&quot;
rpc_user=&quot;user&quot;
rpc_password=&quot;password&quot;
</code></pre>
<p>Note: If <code>rpc_datadir</code> is present, cookie based auth will be used. If you desire to use rpc user / password instead, <code>rpc_datadir</code> should be absent or left blank.</p>
<p>Once we have a configured rpc node, we can issue commands to it directly, as we would with <code>bitcoin-cli</code>. E.g.</p>
<pre><code class="language-bash">bits rpc getdifficulty
</code></pre>
<p>Now, let&#39;s see how we can form transactions with the <a href="https://github.com/jtraub91/bits">bits</a> CLI, and relay them via the local <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> node we&#39;ve configured above.</p>
<h3>Creating raw transactions</h3>
<p>Raw Bitcoin transactions can be created with the <code>bits tx</code> command. As with any subcommand, you may use <code>-h</code> (e.g. <code>bits tx -h</code>) for information on the available options, but the key principle of this command is that it expects any number of <code>--txin</code> (<code>-txin</code>) and <code>--txout</code> (<code>-txout</code>) flags each with an argument provided as a JSON string with the keys &quot;txid&quot;, &quot;vout&quot;, and &quot;scriptsig&quot; or  &quot;satoshis&quot; and &quot;scriptpubkey&quot;, respectively.</p>
<p>For example, suppose we have the following <a href="https://academy.binance.com/en/glossary/unspent-transaction-output-utxo">unspent transaction output</a> (UTXO), associated with the <code>mkmnWvK9fKEQdUcYrpS7gNkxBZ4CACLmKd</code> address.</p>
<pre><code class="language-bash">bits rpc scantxoutset start &#39;[&quot;addr(mkmnWvK9fKEQdUcYrpS7gNkxBZ4CACLmKd)&quot;]&#39; | jq .unspents
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">[
  {
    &quot;txid&quot;: &quot;1c9eb55b17705ca5fc3047d9490ebd3e38422be18fa130dc2389b233767dbc65&quot;,
    &quot;vout&quot;: 0,
    &quot;scriptPubKey&quot;: &quot;76a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88ac&quot;,
    &quot;desc&quot;: &quot;addr(mkmnWvK9fKEQdUcYrpS7gNkxBZ4CACLmKd)#vmpyq35x&quot;,
    &quot;amount&quot;: 50,
    &quot;height&quot;: 109
  }
]
</code></pre>
<p>We can use the &quot;txid&quot; and &quot;vout&quot; shown above, to find more information on this UTXO again using our configured <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> RPC connection.</p>
<pre><code class="language-bash">bits rpc gettxout 1c9eb55b17705ca5fc3047d9490ebd3e38422be18fa130dc2389b233767dbc65 0 | jq .
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">{
  &quot;bestblock&quot;: &quot;2c9574a9db1c9b2178a539e7455e0b84aee06bd5b77e36ae65a89457d96e3e16&quot;,
  &quot;confirmations&quot;: 101,
  &quot;value&quot;: 50,
  &quot;scriptPubKey&quot;: {
    &quot;asm&quot;: &quot;OP_DUP OP_HASH160 39a6b4b85e0108176524ab3b1584f5b9ac21d6da OP_EQUALVERIFY OP_CHECKSIG&quot;,
    &quot;desc&quot;: &quot;addr(mkmnWvK9fKEQdUcYrpS7gNkxBZ4CACLmKd)#vmpyq35x&quot;,
    &quot;hex&quot;: &quot;76a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88ac&quot;,
    &quot;address&quot;: &quot;mkmnWvK9fKEQdUcYrpS7gNkxBZ4CACLmKd&quot;,
    &quot;type&quot;: &quot;pubkeyhash&quot;
  },
  &quot;coinbase&quot;: true
}
</code></pre>
<p>This will show information on the UTXO, including the <a href="https://learnmeabitcoin.com/technical/scriptPubKey">scriptPubKey</a> in assembly (asm) format. Understanding that the UTXO is a P2PKH output will be important as we continue forming the raw transaction, but first, let&#39;s see how we can determine this, using the <code>bits script</code> command, instead of leveraging our configured <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> RPC connection.</p>
<h3>Encoding (and decoding) Script with <code>bits script</code></h3>
<p>We can <em>decode</em> the scriptPubKey shown above, with the <code>bits script</code> command by using the <code>--decode</code> flag. E.g.</p>
<pre><code class="language-bash">bits script 76a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88ac --decode
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">[[&quot;OP_DUP&quot;, &quot;OP_HASH160&quot;, &quot;39a6b4b85e0108176524ab3b1584f5b9ac21d6da&quot;, &quot;OP_EQUALVERIFY&quot;, &quot;OP_CHECKSIG&quot;]]
</code></pre>
<p>We&#39;ll make more use of <code>bits script</code> in a bit (no pun intended üòâ), but let&#39;s first recap where we are at in forming the raw transaction with <code>bits tx</code>.</p>
<p>From either of these prior commands, we learn that the UTXO is a P2PKH output. We need this information to understand how to build the pre-signature transaction image, as well as, form the correct final <a href="https://river.com/learn/terms/s/scriptsig/">scriptSig</a> to unlock the funds. But, we will also need to specify our transaction outputs, indicating the amount of Bitcoin to send and to which address. With Bitcoin, UTXOs are always spent in full, so it is common to have one transaction output indicating our recipient&#39;s address, and another to send the &quot;change&quot; back to an address owned by the sender, sometimes referred to as the &quot;change address&quot;. Also, be aware that this implies that any amount available from a UTXO which is <em>not</em> used in any of the transaction outputs may be assumed as the &quot;miner fee&quot;.  </p>
<p>The UTXO above has 50 BTC (5,000,000,000 satoshis). Let&#39;s send 4,000,000,000 satoshis to <code>mp6UyrvbWH3sq1WRjHnVZr23aJfuwDktZg</code> and use <code>msgrvCT4DagqPAuFoqqCWqBouv43KyRors</code> as the change address, leaving 1000 satoshis available for the miner fee. Remember txouts are supplied as a JSON string with keys &quot;satoshis&quot; (specifying the amount) and &quot;scriptpubkey&quot; (specifying the unlocking script). The addresses <code>mp6UyrvbWH3sq1WRjHnVZr23aJfuwDktZg</code> and <code>msgrvCT4DagqPAuFoqqCWqBouv43KyRors</code> imply a P2PKH transaction output, so to create the scriptpubkey, we can again use <code>bits script</code>. <code>bits script -h</code> includes useful information on how to form various standard transaction scripts.</p>
<p>The pubkey hash that corresponds to  <code>mp6UyrvbWH3sq1WRjHnVZr23aJfuwDktZg</code> and <code>msgrvCT4DagqPAuFoqqCWqBouv43KyRors</code> is <code>5e185942ab1fb90f4880c57384df78dc657a0dba</code> and <code>85812e40cf29f7103731cc6a17b101a4d640aec0</code>, respectively. (This information can be found with <code>bits base58 --check --decode</code>).</p>
<p>Thus, for the transaction output spending to <code>mp6UyrvbWH3sq1WRjHnVZr23aJfuwDktZg</code>, the scriptPubkey becomes</p>
<pre><code class="language-bash">bits script OP_DUP OP_HASH160 5e185942ab1fb90f4880c57384df78dc657a0dba OP_EQUALVERIFY OP_CHECKSIG
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">76a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac
</code></pre>
<p>And for <code>msgrvCT4DagqPAuFoqqCWqBouv43KyRors</code>,</p>
<pre><code class="language-bash">bits script OP_DUP OP_HASH160 85812e40cf29f7103731cc6a17b101a4d640aec0 OP_EQUALVERIFY OP_CHECKSIG
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">76a91485812e40cf29f7103731cc6a17b101a4d640aec088ac
</code></pre>
<p>Putting it all together, and forming the pre-signature transaction data we have,</p>
<pre><code class="language-bash">bits tx -txin &#39;{&quot;txid&quot;: &quot;1c9eb55b17705ca5fc3047d9490ebd3e38422be18fa130dc2389b233767dbc65&quot;, &quot;vout&quot;: 0, &quot;scriptsig&quot;: &quot;76a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88ac&quot;}&#39; -txout &#39;{&quot;satoshis&quot;: 4000000000, &quot;scriptpubkey&quot;: &quot;76a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac&quot;}&#39; -txout &#39;{&quot;satoshis&quot;: 999999000, &quot;scriptpubkey&quot;: &quot;76a91485812e40cf29f7103731cc6a17b101a4d640aec088ac&quot;}&#39;
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000001976a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88acffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000
</code></pre>
<p>Notice that the UTXO&#39;s scriptpubkey is inserted as the scriptsig for the transaction data that used for signing. Now finally, to spend the transaction input, we must sign the transaction data and re-insert the correct scriptsig. For this, we will make use of the <code>bits sig</code> command.</p>
<h3>Signing, and verifying signatures</h3>
<p>With the <code>bits sig</code> command, we can create (and verify) Bitcoin signatures.</p>
<p>To sign the above transaction with the private key associated with the UTXO address (i.e. <code>sender.hex</code>), we can use following command.</p>
<pre><code class="language-bash">bits sig -i sender.hex 010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000001976a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88acffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000 --sighash all
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">3045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a901
</code></pre>
<p>If you would need to verify this signature with the sender&#39;s pubkey (i.e. <code>sender.pub</code>), the following may be used.</p>
<pre><code class="language-bash">echo 02ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fc | bits sig --verify 010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000001976a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88acffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000 --signature 3045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a901
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">OK
</code></pre>
<p>Now that we have the signature, we can form the final scriptsig necessary for this P2PKH UTXO. The scriptsig for a P2PKH output is <code>&lt;signature&gt; &lt;pubkey&gt;</code>, both of which can be found above. Therefore we have,</p>
<pre><code class="language-bash">bits script 3045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a901 02ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fc
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fc
</code></pre>
<p>And now, forming the final transaction</p>
<pre><code class="language-bash">bits tx -txin &#39;{&quot;txid&quot;: &quot;1c9eb55b17705ca5fc3047d9490ebd3e38422be18fa130dc2389b233767dbc65&quot;, &quot;vout&quot;: 0, &quot;scriptsig&quot;: &quot;483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fc&quot;}&#39; -txout &#39;{&quot;satoshis&quot;: 4000000000, &quot;scriptpubkey&quot;: &quot;76a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac&quot;}&#39; -txout &#39;{&quot;satoshis&quot;: 999999000, &quot;scriptpubkey&quot;: &quot;76a91485812e40cf29f7103731cc6a17b101a4d640aec088ac&quot;}&#39;
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000006b483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fcffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000
</code></pre>
<p>Finally, this transaction is ready to be broadcasted to the Bitcoin network. And we can send it using our <a href="#configuring-bits-with-a-local-bitcoin-core-node">configured</a> <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> RPC node. First let&#39;s test the transaction&#39;s validity with,</p>
<pre><code class="language-bash">bits rpc testmempoolaccept &#39;[&quot;010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000006b483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fcffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000&quot;]&#39;
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">[{&#39;txid&#39;: &#39;4ecc3ff0cc54a09b71e4fe5b981bcc930a31e09dfef7f8804b7be4932b251dd2&#39;, &#39;wtxid&#39;: &#39;4ecc3ff0cc54a09b71e4fe5b981bcc930a31e09dfef7f8804b7be4932b251dd2&#39;, &#39;allowed&#39;: True, &#39;vsize&#39;: 226, &#39;fees&#39;: {&#39;base&#39;: 1e-05}}]
</code></pre>
<p>And then actually send it with</p>
<pre><code class="language-bash">bits rpc sendrawtransaction &quot;010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000006b483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fcffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000&quot;
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">4ecc3ff0cc54a09b71e4fe5b981bcc930a31e09dfef7f8804b7be4932b251dd2
</code></pre>
<p>Remember, you will need to wait, at least until the transaction is mined in a block, for the transfer of funds to be reflected in the blockchain.</p>
<h4>Decoding raw transactions</h4>
<p>You may also <em>decode</em> this raw transaction using <code>bits tx --decode</code>. E.g.</p>
<pre><code class="language-bash">echo 010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000006b483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fcffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000 | bits tx --decode | jq .
</code></pre>
<h3>A more convenient approach for sending funds: <code>bits send</code></h3>
<p>Forming raw transactions as above, affords us great flexibility, but is a bit tedious. Therefore <a href="https://github.com/jtraub91/bits">bits</a> provides the <code>bits send</code> command, which, as opposed to <code>bits tx</code>, provides a better user inteface, and does some of the tedious steps behind the scenes; thereby trading flexibility for convenience.</p>
<p>The <code>bits send</code> command integrates directly with (and thus depends on) a <a href="#configuring-bits-with-a-local-bitcoin-core-node">configured</a> <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> node.</p>
<p>Let&#39;s see how it works.</p>
<p>Suppose we have 3.125 BTC associated with the SegWit address <code>bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz</code> on a local regtest Bitcoin network. Let&#39;s send half of these funds to a new address, <code>bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca</code>, and use <code>mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c</code> as the change address.</p>
<p>Many of the tedious steps we had to do in <a href="#creating-raw-transactions">creating raw transactions</a> can now be simply expressed as the following.</p>
<pre><code class="language-bash">bits send bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca --send-fraction 0.5 --change-addr mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">010000000189592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa6150000000000ffffffff02a82b5009000000001600146b53716cc77c270471ae3dc6a048ac8904f621a5902f5009000000001976a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac00000000
</code></pre>
<p>We can inspect this output by using a command seen previously, <code>bits tx --decode</code>, i.e.</p>
<pre><code class="language-bash">echo 010000000189592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa6150000000000ffffffff02a82b5009000000001600146b53716cc77c270471ae3dc6a048ac8904f621a5902f5009000000001976a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac00000000 | bits tx --decode | jq .
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">{
  &quot;txid&quot;: &quot;1053c3fe474b13156ad6611d5ebfaf6c500711f7742d5978ad3559d2b8beeeb3&quot;,
  &quot;wtxid&quot;: &quot;1053c3fe474b13156ad6611d5ebfaf6c500711f7742d5978ad3559d2b8beeeb3&quot;,
  &quot;version&quot;: 1,
  &quot;txins&quot;: [
    {
      &quot;txid&quot;: &quot;89592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa615&quot;,
      &quot;vout&quot;: 0,
      &quot;scriptsig&quot;: &quot;&quot;,
      &quot;sequence&quot;: &quot;ffffffff&quot;
    }
  ],
  &quot;txouts&quot;: [
    {
      &quot;value&quot;: 156249000,
      &quot;scriptpubkey&quot;: &quot;00146b53716cc77c270471ae3dc6a048ac8904f621a5&quot;
    },
    {
      &quot;value&quot;: 156250000,
      &quot;scriptpubkey&quot;: &quot;76a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac&quot;
    }
  ],
  &quot;locktime&quot;: 0
}
</code></pre>
<p>By inspecting the output above, we see 156249000 satoshis in a txout associated with a scriptpubkey indicating a payment to the <code>bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca</code> address we used above. This corresponds to half the original amount associated with the sender address of <code>bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz</code>, minus the miner fee (which defaults to 1000 satoshis but may be specified by using the <code>--miner-fee</code> option). We also see the rest of the satoshis being associated in a txout with a scriptpubkey indicating a payment to to our change address of <code>mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c</code>.</p>
<p>However, this raw transaction has not been signed yet. We can see that from the above output by noticing that there is no witness data, which is needed for spenditure from the SegWit sender address, and correspondingly the wtxid is equal to the txid. But, we can do so easily with the <code>bits send</code> command, by provided the private key(s) necessary for spenditure, in <em>extended</em> <a href="https://en.bitcoin.it/wiki/Wallet_import_format">WIF</a> format. The extended WIF encoded private key can be created with the <code>bits wif</code> command.</p>
<h3>Encode (or decode) a private key in extended WIF format</h3>
<p>Building upon WIF and code seen in the <a href="https://github.com/spesmilo/electrum/blob/4.4.0/electrum/bitcoin.py#L618-L625">electrum wallet codebase</a>, <em>extended</em> WIF, allows for encoding a private key with additional data indicating not only its corresponding address type, but also the additional data necessary for spenditure (i.e. the data needed for creating an appropriate scriptsig, such as the redeem script for a P2SH address, for example).</p>
<p>To provide some background, a standard WIF encoded key is defined as the following, encoded in base58check.</p>
<pre><code class="language-text">network version byte + private key + optional 0x01 byte denoting a compressed pubkey
</code></pre>
<p><em>Extended</em> WIF for the purposes here is defined as the following data structure, encoded in base58check.</p>
<pre><code class="language-text">(network version byte + address type offset) + private key + (data)
</code></pre>
<p>To summarize, extended WIF allows us to provide extra information on the specific address type the private key shall correspond to, and the arbitrary data needed to spend it, while being backwards compatible with standard WIF.</p>
<p>The <code>bits wif</code> command makes this encoding task easier for us. To encode the private key associated with the sender address used above, we may use the following, for example.</p>
<p>Assuming the private key is stored in hexadecimal string format in a file named <code>sender_addr.hex</code>, we have,</p>
<pre><code class="language-bash">bits wif -i sender_addr.hex -T p2wpkh -P
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">94oeEPncUHF7hrXPx7bdbSPrar8tx8bUFNihAg6qr6NAN8Txxrb
</code></pre>
<p>We supplied the <code>-T</code> option (<code>--addr-type</code>) to denote a <code>p2wpkh</code> address type and omitted the <code>-D</code> option (<code>--data</code>) for optional data, since a compressed pubkey is implied for SegWit p2wpkh addresses. Information and help on the necessary data as well as the various supported address types for extended WIF, can be seen with the <code>bits wif -h</code> command.</p>
<p>We can also review the encoding, by performing a <em>decode</em> operation with the following.</p>
<pre><code class="language-bash">echo -n 94oeEPncUHF7hrXPx7bdbSPrar8tx8bUFNihAg6qr6NAN8Txxrb | bits wif --decode | jq .
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">{
  &quot;version&quot;: &quot;f0&quot;,
  &quot;network&quot;: &quot;testnet&quot;,
  &quot;addr_type&quot;: &quot;p2wpkh&quot;,
  &quot;key&quot;: &quot;a7fb90f08460ae7cac8ddb29df999e47e942809a48f353d5fcfc84845d759904&quot;,
  &quot;data&quot;: &quot;&quot;
}
</code></pre>
<p>Here we see the decoded address as a JSON structure. We see a version of hex <code>f0</code> indicating the <code>ef</code> testnet/regtest network version byte plus address offset of <code>01</code> for a P2WPKH address. We also see that information being provided by the <code>network</code> and <code>addr_type</code> keys, respectively. Finally we see the decoded private key value in hexadecimal string format, as well as the empty data key value, since no further data was appended.</p>
<p>Now, we can take this key back to our <code>bits send</code> command we used previously to sign the transaction for spenditure from the sender address of <code>bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz</code>.</p>
<h3>Signing the transaction with <code>bits send</code></h3>
<p>Now, we simply take the command we used previously, but also leverage the <code>--sighash</code> option to specify the SIGHASH flag and denote a signing operation is to occur, and provide the WIF key(s) necessary for spenditure via the input, i.e.</p>
<pre><code class="language-bash">echo -n 94oeEPncUHF7hrXPx7bdbSPrar8tx8bUFNihAg6qr6NAN8Txxrb | bits send bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca --send-fraction 0.5 --change-addr mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c --sighash all
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">0100000000010189592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa6150000000000ffffffff02a82b5009000000001600146b53716cc77c270471ae3dc6a048ac8904f621a5902f5009000000001976a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac0247304402202f14ed3b68d8a97faf5c7f176f55d8610d27adf85927d213de88f562d821d2eb02203c04f9b9280038f34de89990852c3b54b94174154be5b01621e9dc5a5c4488d201210365a02c1e0ca4e10aa8ff5283ac0476077c503a440699212744ded7235ba5f87500000000
</code></pre>
<p>Before sending, we can inspect the transaction with <code>bits tx --decode</code>, i.e.</p>
<pre><code class="language-bash">echo 0100000000010189592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa6150000000000ffffffff02a82b5009000000001600146b53716cc77c270471ae3dc6a048ac8904f621a5902f5009000000001976a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac0247304402202f14ed3b68d8a97faf5c7f176f55d8610d27adf85927d213de88f562d821d2eb02203c04f9b9280038f34de89990852c3b54b94174154be5b01621e9dc5a5c4488d201210365a02c1e0ca4e10aa8ff5283ac0476077c503a440699212744ded7235ba5f87500000000 | bits tx --decode | jq .
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">{
  &quot;txid&quot;: &quot;1053c3fe474b13156ad6611d5ebfaf6c500711f7742d5978ad3559d2b8beeeb3&quot;,
  &quot;wtxid&quot;: &quot;30fee44633756231d2bf767b91ca6ad1109538aa5dbbb5e6f3b52cc0dac3aa32&quot;,
  &quot;version&quot;: 1,
  &quot;txins&quot;: [
    {
      &quot;txid&quot;: &quot;89592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa615&quot;,
      &quot;vout&quot;: 0,
      &quot;scriptsig&quot;: &quot;&quot;,
      &quot;sequence&quot;: &quot;ffffffff&quot;
    }
  ],
  &quot;txouts&quot;: [
    {
      &quot;value&quot;: 156249000,
      &quot;scriptpubkey&quot;: &quot;00146b53716cc77c270471ae3dc6a048ac8904f621a5&quot;
    },
    {
      &quot;value&quot;: 156250000,
      &quot;scriptpubkey&quot;: &quot;76a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac&quot;
    }
  ],
  &quot;witnesses&quot;: [
    [
      &quot;304402202f14ed3b68d8a97faf5c7f176f55d8610d27adf85927d213de88f562d821d2eb02203c04f9b9280038f34de89990852c3b54b94174154be5b01621e9dc5a5c4488d201&quot;,
      &quot;0365a02c1e0ca4e10aa8ff5283ac0476077c503a440699212744ded7235ba5f875&quot;
    ]
  ],
  &quot;locktime&quot;: 0
}
</code></pre>
<p>We now see the necessary signature data via the witness. Finally, we can again leverage our <a href="#configuring-bits-with-a-local-bitcoin-core-node">configured</a> <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> RPC node to send the raw transaction, e.g.</p>
<pre><code class="language-bash">bits rpc sendrawtransaction &quot;0100000000010189592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa6150000000000ffffffff02a82b5009000000001600146b53716cc77c270471ae3dc6a048ac8904f621a5902f5009000000001976a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac0247304402202f14ed3b68d8a97faf5c7f176f55d8610d27adf85927d213de88f562d821d2eb02203c04f9b9280038f34de89990852c3b54b94174154be5b01621e9dc5a5c4488d201210365a02c1e0ca4e10aa8ff5283ac0476077c503a440699212744ded7235ba5f87500000000&quot;
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">b3eebeb8d25935ad78592d74f71107506cafbf5e1d61d66a15134b47fec35310
</code></pre>
<p>Again, remember that this transaction must be mined in a block before we can view the fund transfer on the blockchain, (which offers us a nice segway to some of the last subcommands we will demo in this blog) but it should now be clear how <code>bits send</code> can provide an easier and more convenient method for sending funds.</p>
<h3>Mining blocks</h3>
<p>As stated just above, the raw transaction we just sent via our <a href="#configuring-bits-with-a-local-bitcoin-core-node">configured</a> <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> RPC connection won&#39;t be reflected in the blockchain until it is mined. For mainnet, this will happen by some miner on the network at an average rate of every 10 minutes. However, the <a href="https://github.com/jtraub91/bits">bits</a> CLI actually provides the <code>bits mine</code> command to mine blocks, which also depends on a locally configured Bitcoin Core node. This may take a <em>long</em> time in practice for mainnet, but for our demonstration purposes on <em>regtest</em>, this command can be used to mine blocks and receive block rewards quickly. For example, to include the raw transaction we sent above (which is now part of the mempool) in a block, and receive the reward to a new address, e.g. <code>mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ</code>, we can use the following.</p>
<pre><code class="language-bash">bits mine --limit 1 --recv-addr mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">1 blocks mined. Reward sent to mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ
</code></pre>
<p>The <code>--limit</code> option is used to only mine the indicated number of blocks. If this option is omitted the <code>bits mine</code> command will mine indefinitely. Also, <code>--recv-addr</code> is used to indicate the address that the block reward shall be sent to.</p>
<p>Now with the previous transaction mined in a block, the following command can show us the respective amounts now allocated to the various addresses used in this demonstration.</p>
<pre><code class="language-bash">bits rpc scantxoutset start &#39;[&quot;addr(bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz)&quot;, &quot;addr(bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca)&quot;, &quot;addr(mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c)&quot;, &quot;addr(mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ)&quot;]&#39; | jq .
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">{
  &quot;success&quot;: true,
  &quot;txouts&quot;: 830,
  &quot;height&quot;: 828,
  &quot;bestblock&quot;: &quot;1f0f9cfb4360b649dbe4581e369dd0b80e3e7177a560f4f73e5c3873ba6f996f&quot;,
  &quot;unspents&quot;: [
    {
      &quot;txid&quot;: &quot;b3eebeb8d25935ad78592d74f71107506cafbf5e1d61d66a15134b47fec35310&quot;,
      &quot;vout&quot;: 0,
      &quot;scriptPubKey&quot;: &quot;00146b53716cc77c270471ae3dc6a048ac8904f621a5&quot;,
      &quot;desc&quot;: &quot;addr(bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca)#qq7tl9lw&quot;,
      &quot;amount&quot;: 1.56249,
      &quot;height&quot;: 828
    },
    {
      &quot;txid&quot;: &quot;b3eebeb8d25935ad78592d74f71107506cafbf5e1d61d66a15134b47fec35310&quot;,
      &quot;vout&quot;: 1,
      &quot;scriptPubKey&quot;: &quot;76a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac&quot;,
      &quot;desc&quot;: &quot;addr(mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c)#nxeam3zm&quot;,
      &quot;amount&quot;: 1.5625,
      &quot;height&quot;: 828
    },
    {
      &quot;txid&quot;: &quot;53b49c2022496267c0f962422b2a4fc27d09f88472a5536dd5640a36a2e5df63&quot;,
      &quot;vout&quot;: 0,
      &quot;scriptPubKey&quot;: &quot;76a914a557ee47fee5eb85822017b26c03b9d1884a19e088ac&quot;,
      &quot;desc&quot;: &quot;addr(mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ)#4j85pt9g&quot;,
      &quot;amount&quot;: 1.5625,
      &quot;height&quot;: 828
    }
  ],
  &quot;total_amount&quot;: 4.68749
}
</code></pre>
<p>Note that per consensus rules, the block reward will remain unavailable for spenditure for 100 blocks; so to make the funds now associated with <code>mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ</code> immediately available, we can mine 100 blocks, e.g.</p>
<pre><code class="language-bash">bits mine --limit 100 --recv-addr &quot;&quot;
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">100 blocks mined. Reward sent to
</code></pre>
<p>Note that we provided an empty <code>--recv-addr</code> for demo purposes since we do not care about the block reward in this instance on regtest. This is not recommended for production purposes on mainnet! ü§ë</p>
<h3>Closing bits</h3>
<p>That about wraps it up for this blog post, but before we go, there are a couple more subcommands I&#39;d like to explain.</p>
<p>Though unsupported (nor functionl nor advised üòÖ), there does exist a <code>bits p2p</code> command , which intends to eventually implement a functional native full node for <a href="https://github.com/jtraub91/bits">bits</a>, which would thereby deprecate support for <a href="#configuring-bits-with-a-local-bitcoin-core-node">configuring</a> a <a href="https://github.com/bitcoin/bitcoin">Bitcoin Core</a> RPC connection. Exposing this subcommand is only to show users what is in the codebase today, and to help to illustrate what is planned for future. Play around or hack on it, but don&#39;t expect it to do anything too useful at present.</p>
<p>Finally, the last subcommand I will mention is the <code>bits blockchain</code> command. Again, this command is planned to be able to explore and retrieve blockchain data, and will depend on a functioning <code>bits p2p</code> full node. In the meantime it supports <em>decoding</em> raw blocks (via <code>bits blockchain --decode</code>), which can be useful for debugging. Other than that, it currently supports retrieving only the hard-coded genesis block of the Bitcoin blockchain, at the block height of 0, e.g.</p>
<pre><code class="language-bash">bits blockchain 0
</code></pre>
<p>Output:</p>
<pre><code class="language-bash">01000000000000000000000000000000000000000000000000000000000000000000000001000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac0000000029ab5f49ffff001d1dac2b7c0101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000
</code></pre>
<p>Like many <code>bits</code> subcommands, the output can be specified as raw binary, for which may be interesting to view, as this output contains some notable historical information üòâ.</p>
<pre><code class="language-bash">bits blockchain 0 -0
</code></pre>
<p>That concludes this post! Thanks for bearing with me üôè I hope you find this cli tool and library to be useful. Please feel free to reach out for questions or to just say hi üëã Till next time ‚úåÔ∏è üòé ‚ù§Ô∏è</p>
<h3>Citations</h3>
<ol>
<li><a href="https://linux.die.net/man/1/xxd">xxd man page</a></li>
<li><a href="https://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a></li>
</ol>
<!----></article><!----></div><!----><!----></div> <footer class="bottom-0 w-full flex flex-row text-gray-500 text-xs"><span class="m-auto p-2">¬© 2025 Jason Traub</span></footer><!----></div><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_o647dc = {
						base: new URL("..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../_app/immutable/entry/start.CQlWdkbR.js"),
						import("../_app/immutable/entry/app.VedFBwoq.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data: [null,{"type":"data","data":{content:"\u003Cp>Introducing \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a>, a free and open source cli tool and pure Python library developed for Bitcoin.\u003C/p>\n\u003Cp>This post will serve as informal documentation for some of what you can do with \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> today, and what is planned for the future.\u003C/p>\n\u003Ch2>Installation\u003C/h2>\n\u003Cpre>\u003Ccode class=\"language-bash\">git clone https://github.com/jtraub91/bits\ncd bits/\npip install .\n\u003C/code>\u003C/pre>\n\u003Ch2>Usage\u003C/h2>\n\u003Cp>\u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> is pure Python, and thus, can be used as a library by calling its various functions and methods directly (with documentation coming soon üöÄ); however, often it&#39;s convenient to simply use a command line interface (CLI) to common functionality. The \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> CLI provides many different methods which are explained in detail in the subsequent sections.\u003C/p>\n\u003Ch2>Command Line Interface\u003C/h2>\n\u003Ch3>The \u003Ccode>bits\u003C/code> base command\u003C/h3>\n\u003Cp>The \u003Ccode>bits\u003C/code> command, by itself, with no subcommand present, is a command in its own rite which will &quot;convert input bits to bytes&quot;.\u003C/p>\n\u003Cp>To elaborate, three input / output (I/O) formats are supported: raw bytes, binary string, and hexadecimal string, which may be specified independently making \u003Ccode>bits\u003C/code> able to be used as a converter between these formats. Raw bytes are read transparently; however, binary string and hexadecimal string input is stripped of leading or trailing whitespace, \u003Cem>and\u003C/em> left zero padded to the nearest byte if not provided as an integer multiple of 8 bits. Furthermore, raw bytes are output as-is, yet binary and hexadecimal string will be output will have a trailing newline character.\u003C/p>\n\u003Ch4>Comparing to \u003Ccode>xxd\u003C/code>\u003C/h4>\n\u003Cp>The \u003Ccode>bits\u003C/code> base command, sharing functionality with standard Linux utility \u003Ca href=\"https://linux.die.net/man/1/xxd\">xxd\u003C/a>, can be used similarly in some respects.\u003C/p>\n\u003Cp>With \u003Ccode>xxd\u003C/code>, we can convert a raw binary input to a hex string like so,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">head -c 8 /dev/urandom | xxd -p\n\u003C/code>\u003C/pre>\n\u003Cp>Similarly we can do the following with \u003Ccode>bits\u003C/code>\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">head -c 8 /dev/urandom | bits -1 -0x\n\u003C/code>\u003C/pre>\n\u003Cp>The \u003Ccode>-1\u003C/code> indicates that the \u003Cem>input\u003C/em> is raw bytes, while the \u003Ccode>-0x\u003C/code> flag indicates the \u003Cem>output\u003C/em> shall be a hexadecimal string. In general, these flags can be ommitted, but unless otherwise \u003Ca href=\"https://github.com/jtraub91/bits#configuration\">configured\u003C/a>, the default I/O format for most commands is hexadecimal string.\u003C/p>\n\u003Cp>The \u003Ccode>bits\u003C/code> command will output the string on a single line, whereas with \u003Ccode>xxd\u003C/code> we may have to use the \u003Ccode>-c\u003C/code> argument to achieve a similar result. For example,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">head -c 32 /dev/urandom | xxd -p -c 32\n\u003C/code>\u003C/pre>\n\u003Cp>becomes simply\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">head -c 32 /dev/urandom | bits -1 \n\u003C/code>\u003C/pre>\n\u003Cp>(As alluded to above, with \u003Ccode>-0x\u003C/code> omitted, and no other configuration, the output format defaults to hexadecimal string)\u003C/p>\n\u003Cp>Furthermore, the support for binary strings provides functionality that \u003Ccode>xxd\u003C/code> does not (nor any other CLI tool that I am aware of), in that it can convert between binary string representation. For example, with \u003Ccode>xxd\u003C/code> in \u003Ccode>-bits\u003C/code> (\u003Ccode>-b\u003C/code>) mode, we can do,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">head -c 32 /dev/urandom | xxd -b\n\u003C/code>\u003C/pre>\n\u003Cp>to get a binary string representation of the input; but it outputs it in octets, which may be inconvenient for further processing. Furthermore, the \u003Ccode>-revert\u003C/code> (\u003Ccode>-r\u003C/code>) flag &quot;[does] not work with [\u003Ccode>-bits\u003C/code>] mode&quot;. \u003Ca href=\"#citations\">[1]\u003C/a>\u003C/p>\n\u003Cp>So with \u003Ccode>xxd\u003C/code> we can convert raw bytes to a hexadecimal string, and revert.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">head -c 32 /dev/urandom | xxd -p -c 32 | xxd -r -p\n\u003C/code>\u003C/pre>\n\u003Cp>But, we cannot do the same with \u003Ccode>-b\u003C/code>\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">head -c 32 /dev/urandom | xxd -b | xxd -r -b\nxxd: sorry, cannot revert this type of hexdump\n\u003C/code>\u003C/pre>\n\u003Cp>But, we can with \u003Ccode>bits\u003C/code>\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">head -c 32 /dev/urandom | bits -1 -0b | bits -1b -0\n\u003C/code>\u003C/pre>\n\u003Ch3>CLI subcommands\u003C/h3>\n\u003Cp>Now, let&#39;s get into some of the more useful and specific Bitcoin functions that \u003Ccode>bits\u003C/code> provides. These are provided by various \u003Cem>subcommands\u003C/em>. You can view a full list of available subcommands with\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits -h\n\u003C/code>\u003C/pre>\n\u003Cp>Subcommand specific help is also available with\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits &lt;subcommand&gt; -h\n\u003C/code>\u003C/pre>\n\u003Ch3>Generate a Bitcoin private key\u003C/h3>\n\u003Cp>The \u003Ccode>bits key\u003C/code> command will generate a bitcoin private key, which is nothing but a 256 bit random value strictly less than \u003Ccode>SECP256K1_N\u003C/code>. \u003Ca href=\"#citations\">[2]\u003C/a>\u003C/p>\n\u003Cp>This, you may notice, \u003Cem>can\u003C/em> be generated with the base command, e.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">head -c 32 /dev/urandom | bits -1\n\u003C/code>\u003C/pre>\n\u003Cp>but instead of having to manually confirm the output is below \u003Ccode>SECP256K1_N\u003C/code> you can use \u003Ccode>bits key\u003C/code> instead for convenience.\u003C/p>\n\u003Cp>Also, note that if a command has input or output, it will accept an \u003Ccode>--input-file\u003C/code> (\u003Ccode>-in\u003C/code>, \u003Ccode>-i\u003C/code>) and/or \u003Ccode>--out-file\u003C/code> (\u003Ccode>-out\u003C/code>, \u003Ccode>-o\u003C/code>) optional argument, defaulting to stdin or stdout, respectively. (Also, as applicable, a command with input or output will usually include the input and output format flags illustrated above for the \u003Ca href=\"#the-bits-base-command\">bits base command\u003C/a>). Thus, to conceal the private key from being exposed on the command line, you may use the following command, for example.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits key -out secret.hex\n\u003C/code>\u003C/pre>\n\u003Cp>(or standard shell redirection, e.g. \u003Ccode>bits key &gt; secret.hex\u003C/code>)\u003C/p>\n\u003Cp>For compatibility with legacy tooling (if you&#39;re into that sort of thing), the \u003Ccode>bits key\u003C/code> command supports PEM-encoded private key output, e.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits key -0pem\n\u003C/code>\u003C/pre>\n\u003Cp>Note that \u003Ccode>bits\u003C/code> \u003Cem>does not\u003C/em> currently provide support for PEM-encoded \u003Cem>input\u003C/em> on the CLI, so you will need to convert back to a supported format (raw, bin, hex) in order to use with other \u003Ccode>bits\u003C/code> (sub)commands. This can be done with \u003Ca href=\"https://www.openssl.org/\">openssl\u003C/a> (\u003Ccode>openssl ec\u003C/code> or \u003Ccode>openssl asn1parse\u003C/code>, for example).\u003C/p>\n\u003Ch3>Create a public key from a private key\u003C/h3>\n\u003Cp>The \u003Ccode>bits pubkey\u003C/code> command generates a public key (pubkey) from a private key. E.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits pubkey -in secret.hex\n\u003C/code>\u003C/pre>\n\u003Cp>You may output a compressed pubkey with the \u003Ccode>--compressed\u003C/code> (\u003Ccode>-X\u003C/code>) flag.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits pubkey -in secret.hex -X -out pubkey.hex\n\u003C/code>\u003C/pre>\n\u003Cp>Notice we leverage the \u003Ccode>-out\u003C/code> flag again above to save the pubkey to a file.\u003C/p>\n\u003Ch3>Creating a bitcoin address\u003C/h3>\n\u003Cp>Now, you may want to create a Bitcoin address from your key pair. The \u003Ccode>bits addr\u003C/code> command provides a convenient method to handle the encoding for various address types. This command supports generating legacy and segwit addresses alike, but expects the payload to passed in as the argument. For example, for legacy \u003Ca href=\"https://learnmeabitcoin.com/technical/p2pkh\">pay to pubkey hash\u003C/a> addresses (P2PKH), we&#39;ll need to hash the pubkey first with \u003Ccode>hash160\u003C/code>. The \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> CLI fortunately provides the \u003Ccode>ripemd160\u003C/code>, \u003Ccode>sha256\u003C/code>, \u003Ccode>hash160\u003C/code>, and \u003Ccode>hash256\u003C/code> crypto hashing subcommands for convenience. Thus, to generate a legacy Bitcoin address from our pubkey, we may use the following, for example.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits hash160 -in pubkey.hex | bits addr | awk &#39;{print $1}&#39;\n\u003C/code>\u003C/pre>\n\u003Cp>In the above example, the pubkey saved to \u003Ccode>pubkey.hex\u003C/code> is read as input to \u003Ccode>bits hash160\u003C/code>, thus is hashed, and piped to the \u003Ccode>bits addr\u003C/code> command to complete the encoding. The output of \u003Ccode>bits addr\u003C/code> is then piped into \u003Ccode>awk\u003C/code> only for readability, i.e. to produce a newline on the shell output since \u003Ccode>bits addr\u003C/code> will technically output raw binary, with no newline appended; however, in these situations \u003Ccode>bits\u003C/code> provides the \u003Ccode>--print\u003C/code> (\u003Ccode>-P\u003C/code>) flag to do the same, for convenience. E.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits hash160 -in pubkey.hex | bits addr -P\n\u003C/code>\u003C/pre>\n\u003Cp>The \u003Ccode>bits addr\u003C/code> command accepts a \u003Ccode>--type\u003C/code> (\u003Ccode>-T\u003C/code>) flag for address type which defaults to &quot;p2pkh&quot; for P2PKH addresses, but may be specified to be &quot;p2sh&quot; for \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki\">BIP16\u003C/a> \u003Ca href=\"https://learnmeabitcoin.com/technical/p2sh\">pay to script hash\u003C/a> (P2SH) addresses.\u003C/p>\n\u003Cp>A testnet address may be generated instead by leveraging the \u003Ccode>--network\u003C/code> (\u003Ccode>-N\u003C/code>) flag. E.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits hash160 -in pubkey.hex | bits addr -N testnet -P\n\u003C/code>\u003C/pre>\n\u003Cp>Segwit addresses can be generated similarly, e.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits hash160 -in pubkey.hex | bits addr --witness-version 0 -P\n\u003C/code>\u003C/pre>\n\u003Cp>The presence of the \u003Ccode>--witness-version\u003C/code> (\u003Ccode>--wv\u003C/code>) flag indicates a segwit address and its value represents the version. When this flag is present the \u003Ccode>--type\u003C/code> flag is ignored. Segwit addresses, per \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki\">BIP 141\u003C/a>, identify themselves as \u003Ca href=\"https://river.com/learn/terms/p/p2wpkh/\">pay to witness key hash\u003C/a> (P2WKH) or \u003Ca href=\"https://river.com/learn/terms/p/p2wsh/\">pay to witness script hash\u003C/a> (P2WSH) by the size of their payload, thus the user is expected to form and provide the correct payload as necessary.\u003C/p>\n\u003Cp>The \u003Ccode>bits addr\u003C/code> command isn&#39;t doing anything magical üßô‚Äç‚ôÇÔ∏è It accepts a payload and optional network and address type (or witness version) arguments, prepends the correct version byte and encodes in \u003Ca href=\"https://en.bitcoin.it/wiki/Base58Check_encoding\">base58check\u003C/a> or \u003Ca href=\"https://en.bitcoin.it/wiki/Bech32\">bech32\u003C/a> (\u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki\">BIP 173\u003C/a>), as appropriate. This can also be done manually with other \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> CLI subcommands as we will see in the next section.\u003C/p>\n\u003Ch3>Encoding (and decoding) with \u003Ccode>base58\u003C/code> and \u003Ccode>bech32\u003C/code>\u003C/h3>\n\u003Cp>The \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> CLI provides methods for encoding and decoding base58(check) and bech32.\u003C/p>\n\u003Cp>Recreating what was performed above by the \u003Ccode>bits addr\u003C/code> command, but instead with \u003Ccode>bits base58\u003C/code> and \u003Ccode>bits bech32\u003C/code>, repectively, we could do the following, for example.\u003C/p>\n\u003Cp>For legacy P2PKH addresses:\u003C/p>\n\u003Cul>\n\u003Cli>Take your pubkey and hash it like before\u003C/li>\n\u003Cli>Pre-prend the version byte (\u003Ccode>0x00\u003C/code> for mainnet)\u003C/li>\n\u003Cli>Encode with \u003Ca href=\"https://en.bitcoin.it/wiki/Base58Check_encoding\">base58check\u003C/a>\u003C/li>\n\u003C/ul>\n\u003Cp>Doing this, all at once, on the command line, would look something like the following.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits hash160 -in pubkey.hex | awk &#39;{print &quot;00&quot;$1}&#39; | bits base58 --check\n\u003C/code>\u003C/pre>\n\u003Cp>The \u003Ccode>--check\u003C/code> option is supplied so that the checksum is appended. The \u003Ccode>bits base58\u003C/code> command also supports a \u003Ccode>--decode\u003C/code> option for retrieving the original payload, e.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo -n &lt;base58-check-encoded-address&gt; | bits base58 --check --decode\n\u003C/code>\u003C/pre>\n\u003Cp>The \u003Ccode>--check\u003C/code> flag with the \u003Ccode>--decode\u003C/code> flag present will make \u003Ccode>bits\u003C/code> ensure that the checksum is valid.\u003C/p>\n\u003Cp>Similarly, we can reproduce segwit address we previously created with \u003Ccode>bits addr\u003C/code>, instead with \u003Ccode>bits bech32\u003C/code>.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits hash160 -in pubkey.hex | bits bech32 --hrp bc --wv 0 -P\n\u003C/code>\u003C/pre>\n\u003Cp>As we can see, the \u003Ccode>bits bech32\u003C/code> command gives us a little bit more flexibility with regard to the \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32\">bech32 specification\u003C/a>, whereas \u003Ccode>bits addr\u003C/code> provides practical convenience. With \u003Ccode>bits bech32\u003C/code> we can supply an arbitrary human readable part via \u003Ccode>--hrp\u003C/code> and an optional Segwit version via the \u003Ccode>--witness-version\u003C/code> (\u003Ccode>--wv\u003C/code>) flag. From there, the data passed as input is encoded, with checksum appended. Alternatively, the \u003Ccode>bits addr\u003C/code> command provides convenience by performing the address encoding as inferred from the options provided, i.e. \u003Ccode>--network\u003C/code> (\u003Ccode>-N\u003C/code>), \u003Ccode>--type\u003C/code> (\u003Ccode>-T\u003C/code>), and \u003Ccode>--witness-version\u003C/code> (\u003Ccode>--wv\u003C/code>).\u003C/p>\n\u003Cp>Furthermore, we can also \u003Cem>decode\u003C/em> bech32, e.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo -n &lt;bech32-encoded&gt; | bits bech32 --decode\n\u003C/code>\u003C/pre>\n\u003Cp>The output of the previous commnd is a JSON string. If input is determined to be a segwit address, the output will have the keys &quot;network&quot;, &quot;witness_version&quot;, and &quot;witness_program&quot;; otherwise the keys will be &quot;hrp&quot; and &quot;payload&quot;.\u003C/p>\n\u003Ch3>Mnemonic seeds and HD wallet operations\u003C/h3>\n\u003Cp>\u003Ccode>bits\u003C/code> provides two subcommands for mnemonic / seed generation and hierarchical deterministic wallets per \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\">BIP32\u003C/a>, \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\">BIP39\u003C/a>, \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki\">BIP43\u003C/a>, and \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">BIP44\u003C/a>: \u003Ccode>bits mnemonic\u003C/code> and \u003Ccode>bits hd\u003C/code>.\u003C/p>\n\u003Cp>To generate a mnemonic seed phrase you may simply use the following.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits mnemonic\n\u003C/code>\u003C/pre>\n\u003Cp>This command also supports providing your own entropy. For example,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">head -c 32 /dev/urandom | bits mnemonic -1 --from-entropy\n\u003C/code>\u003C/pre>\n\u003Cp>Furthermore, we can provide the generated mnemonic as input to the \u003Ccode>bits mnemonic\u003C/code> command, with the \u003Ccode>--to-seed\u003C/code> or \u003Ccode>--to-master-key\u003C/code> options present to generate the seed or master key (per \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#master-key-generation\">BIP 32\u003C/a>), respectively. These options will cause \u003Ccode>bits mnemonic\u003C/code> to prompt for a passphrase at the CLI (which can be blank).\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo &lt;mnemonic-phrase&gt; | bits mnemonic --to-master-key\npassphrase: \n\u003C/code>\u003C/pre>\n\u003Cp>The base58check-encoded master key, provided as output of the previous command, is needed for further derivation with the \u003Ccode>bits hd\u003C/code> command.\u003C/p>\n\u003Cp>With \u003Ccode>bits hd\u003C/code> you may derive private extended private keys (xprv) or extended public keys (xpub) by supplying the root key and a derivation path per \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\">BIP32\u003C/a>, \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki\">BIP43\u003C/a>, and/or \u003Ca href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\">BIP44\u003C/a>. For example,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo -n &lt;root-key&gt; | bits hd &quot;m/44&#39;/0&#39;/0&#39;/0/0&quot;\n\u003C/code>\u003C/pre>\n\u003Cp>The leading \u003Ccode>m\u003C/code> indicates private key derivation, implying that a xprv must be supplied as input. The command will then derive and return the xprv at the derivation path provided, \u003Cem>but\u003C/em> the xpub can be returned instead by supplying the \u003Ccode>--xpub\u003C/code> flag. E.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo -n &lt;root-key&gt; | bits hd &quot;m/44&#39;/0&#39;/0&#39;/0/0&quot; --xpub\n\u003C/code>\u003C/pre>\n\u003Cp>Also, a deserialized key can be emitted to stderr as a JSON string (with keys &quot;version&quot;, &quot;depth&quot;, &quot;parent_key_fingerprint&quot;, &quot;child_no&quot;, and &quot;key&quot;) by supplying the optional \u003Ccode>--dump\u003C/code> flag.\u003C/p>\n\u003Cp>Public derivation is supported and can be used by indicating a capital \u003Ccode>M\u003C/code> in the derivation path. E.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo -n &lt;xpub&gt; | bits hd &quot;M/0&quot; \n\u003C/code>\u003C/pre>\n\u003Cp>Also, of note, is that you aren&#39;t required to use the \u003Cem>root\u003C/em> master key as input for the derivation. Any derived key can be used as the starting point, and derivation will happen relative to it. This may be useful in practice, so as to not expose the root master key on the same machine that derivation is performed.\u003C/p>\n\u003Ch3>Leveraging a Bitcoin Core Node\u003C/h3>\n\u003Cp>So far we&#39;ve seen that the \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> CLI is able to do some basic bits to bytes manipulations and provide some utilites for generating and managing Bitcoin keys, addresses, and whatnot. What \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> \u003Cem>does not\u003C/em> do, currently, is provide a full node for consensus. For now, I recommend having a local \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> node running (i.e. \u003Ccode>bitcoind\u003C/code>) so that blockchain data can be downloaded, transactions can be relayed, and a node for verifying and maintaining consensus can be employed, strengthening the Bitcoin network.\u003C/p>\n\u003Cp>Part of the plan for \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> is to implement a full node, with built-in \u003Ca href=\"https://en.wikipedia.org/wiki/Remote_procedure_call\">RPC\u003C/a> server, by version 1. There does actually exist code in the codebase that has started to implement such, but it is not currently very functional nor supported.\u003C/p>\n\u003Cp>So in the meantime, I recommend leveraging \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> here. As we continue thru this blog, you may want a \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> node while using subcommands such as \u003Ccode>bits tx\u003C/code>, for looking up necessary blockchain data, but additionally and moreover, \u003Ccode>bits\u003C/code> can be configured to directly interact with \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> over RPC, either by sending raw RPC commands via the \u003Ccode>bits rpc\u003C/code> command, or by leveraging it internally, as with the \u003Ccode>bits send\u003C/code> command, for example. These will be explained, in detail, in the following sections.\u003C/p>\n\u003Cp>To download a \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> binary for installation on your OS, see \u003Ca href=\"https://bitcoincore.org/en/download/\">downloads\u003C/a>.\u003C/p>\n\u003Ch3>Configuring \u003Ccode>bits\u003C/code> with a local Bitcoin Core node\u003C/h3>\n\u003Cp>Nominal bits configuration is located in your user&#39;s home directory, in a directory named \u003Ccode>.bits\u003C/code>, in a file named either \u003Ccode>config.toml\u003C/code> or \u003Ccode>config.json\u003C/code>, depending on \u003Ca href=\"https://github.com/jtraub91/bits#config-file-support\">config file support\u003C/a>.\u003C/p>\n\u003Cp>You may configure a connection via RPC with either cookie based authentication or a user &amp; password. To connect via cookie based authentication, all you should configure is \u003Ccode>rpc_url\u003C/code> and \u003Ccode>rpc_datadir\u003C/code>. These may be specified at the CLI for dependent subcommands, or configured in \u003Ccode>~/.bits/config.toml\u003C/code>, for example.\u003C/p>\n\u003Cp>For cookie based auth,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-toml\">rpc_url=&quot;http://localhost:8332&quot;\nrpc_datadir=&quot;~/.bitcoin&quot;\n\u003C/code>\u003C/pre>\n\u003Cp>Or for rpc user / password,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-toml\">rpc_url=&quot;http://localhost:8332&quot;\nrpc_user=&quot;user&quot;\nrpc_password=&quot;password&quot;\n\u003C/code>\u003C/pre>\n\u003Cp>Note: If \u003Ccode>rpc_datadir\u003C/code> is present, cookie based auth will be used. If you desire to use rpc user / password instead, \u003Ccode>rpc_datadir\u003C/code> should be absent or left blank.\u003C/p>\n\u003Cp>Once we have a configured rpc node, we can issue commands to it directly, as we would with \u003Ccode>bitcoin-cli\u003C/code>. E.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits rpc getdifficulty\n\u003C/code>\u003C/pre>\n\u003Cp>Now, let&#39;s see how we can form transactions with the \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> CLI, and relay them via the local \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> node we&#39;ve configured above.\u003C/p>\n\u003Ch3>Creating raw transactions\u003C/h3>\n\u003Cp>Raw Bitcoin transactions can be created with the \u003Ccode>bits tx\u003C/code> command. As with any subcommand, you may use \u003Ccode>-h\u003C/code> (e.g. \u003Ccode>bits tx -h\u003C/code>) for information on the available options, but the key principle of this command is that it expects any number of \u003Ccode>--txin\u003C/code> (\u003Ccode>-txin\u003C/code>) and \u003Ccode>--txout\u003C/code> (\u003Ccode>-txout\u003C/code>) flags each with an argument provided as a JSON string with the keys &quot;txid&quot;, &quot;vout&quot;, and &quot;scriptsig&quot; or  &quot;satoshis&quot; and &quot;scriptpubkey&quot;, respectively.\u003C/p>\n\u003Cp>For example, suppose we have the following \u003Ca href=\"https://academy.binance.com/en/glossary/unspent-transaction-output-utxo\">unspent transaction output\u003C/a> (UTXO), associated with the \u003Ccode>mkmnWvK9fKEQdUcYrpS7gNkxBZ4CACLmKd\u003C/code> address.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits rpc scantxoutset start &#39;[&quot;addr(mkmnWvK9fKEQdUcYrpS7gNkxBZ4CACLmKd)&quot;]&#39; | jq .unspents\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">[\n  {\n    &quot;txid&quot;: &quot;1c9eb55b17705ca5fc3047d9490ebd3e38422be18fa130dc2389b233767dbc65&quot;,\n    &quot;vout&quot;: 0,\n    &quot;scriptPubKey&quot;: &quot;76a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88ac&quot;,\n    &quot;desc&quot;: &quot;addr(mkmnWvK9fKEQdUcYrpS7gNkxBZ4CACLmKd)#vmpyq35x&quot;,\n    &quot;amount&quot;: 50,\n    &quot;height&quot;: 109\n  }\n]\n\u003C/code>\u003C/pre>\n\u003Cp>We can use the &quot;txid&quot; and &quot;vout&quot; shown above, to find more information on this UTXO again using our configured \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> RPC connection.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits rpc gettxout 1c9eb55b17705ca5fc3047d9490ebd3e38422be18fa130dc2389b233767dbc65 0 | jq .\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">{\n  &quot;bestblock&quot;: &quot;2c9574a9db1c9b2178a539e7455e0b84aee06bd5b77e36ae65a89457d96e3e16&quot;,\n  &quot;confirmations&quot;: 101,\n  &quot;value&quot;: 50,\n  &quot;scriptPubKey&quot;: {\n    &quot;asm&quot;: &quot;OP_DUP OP_HASH160 39a6b4b85e0108176524ab3b1584f5b9ac21d6da OP_EQUALVERIFY OP_CHECKSIG&quot;,\n    &quot;desc&quot;: &quot;addr(mkmnWvK9fKEQdUcYrpS7gNkxBZ4CACLmKd)#vmpyq35x&quot;,\n    &quot;hex&quot;: &quot;76a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88ac&quot;,\n    &quot;address&quot;: &quot;mkmnWvK9fKEQdUcYrpS7gNkxBZ4CACLmKd&quot;,\n    &quot;type&quot;: &quot;pubkeyhash&quot;\n  },\n  &quot;coinbase&quot;: true\n}\n\u003C/code>\u003C/pre>\n\u003Cp>This will show information on the UTXO, including the \u003Ca href=\"https://learnmeabitcoin.com/technical/scriptPubKey\">scriptPubKey\u003C/a> in assembly (asm) format. Understanding that the UTXO is a P2PKH output will be important as we continue forming the raw transaction, but first, let&#39;s see how we can determine this, using the \u003Ccode>bits script\u003C/code> command, instead of leveraging our configured \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> RPC connection.\u003C/p>\n\u003Ch3>Encoding (and decoding) Script with \u003Ccode>bits script\u003C/code>\u003C/h3>\n\u003Cp>We can \u003Cem>decode\u003C/em> the scriptPubKey shown above, with the \u003Ccode>bits script\u003C/code> command by using the \u003Ccode>--decode\u003C/code> flag. E.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits script 76a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88ac --decode\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">[[&quot;OP_DUP&quot;, &quot;OP_HASH160&quot;, &quot;39a6b4b85e0108176524ab3b1584f5b9ac21d6da&quot;, &quot;OP_EQUALVERIFY&quot;, &quot;OP_CHECKSIG&quot;]]\n\u003C/code>\u003C/pre>\n\u003Cp>We&#39;ll make more use of \u003Ccode>bits script\u003C/code> in a bit (no pun intended üòâ), but let&#39;s first recap where we are at in forming the raw transaction with \u003Ccode>bits tx\u003C/code>.\u003C/p>\n\u003Cp>From either of these prior commands, we learn that the UTXO is a P2PKH output. We need this information to understand how to build the pre-signature transaction image, as well as, form the correct final \u003Ca href=\"https://river.com/learn/terms/s/scriptsig/\">scriptSig\u003C/a> to unlock the funds. But, we will also need to specify our transaction outputs, indicating the amount of Bitcoin to send and to which address. With Bitcoin, UTXOs are always spent in full, so it is common to have one transaction output indicating our recipient&#39;s address, and another to send the &quot;change&quot; back to an address owned by the sender, sometimes referred to as the &quot;change address&quot;. Also, be aware that this implies that any amount available from a UTXO which is \u003Cem>not\u003C/em> used in any of the transaction outputs may be assumed as the &quot;miner fee&quot;.  \u003C/p>\n\u003Cp>The UTXO above has 50 BTC (5,000,000,000 satoshis). Let&#39;s send 4,000,000,000 satoshis to \u003Ccode>mp6UyrvbWH3sq1WRjHnVZr23aJfuwDktZg\u003C/code> and use \u003Ccode>msgrvCT4DagqPAuFoqqCWqBouv43KyRors\u003C/code> as the change address, leaving 1000 satoshis available for the miner fee. Remember txouts are supplied as a JSON string with keys &quot;satoshis&quot; (specifying the amount) and &quot;scriptpubkey&quot; (specifying the unlocking script). The addresses \u003Ccode>mp6UyrvbWH3sq1WRjHnVZr23aJfuwDktZg\u003C/code> and \u003Ccode>msgrvCT4DagqPAuFoqqCWqBouv43KyRors\u003C/code> imply a P2PKH transaction output, so to create the scriptpubkey, we can again use \u003Ccode>bits script\u003C/code>. \u003Ccode>bits script -h\u003C/code> includes useful information on how to form various standard transaction scripts.\u003C/p>\n\u003Cp>The pubkey hash that corresponds to  \u003Ccode>mp6UyrvbWH3sq1WRjHnVZr23aJfuwDktZg\u003C/code> and \u003Ccode>msgrvCT4DagqPAuFoqqCWqBouv43KyRors\u003C/code> is \u003Ccode>5e185942ab1fb90f4880c57384df78dc657a0dba\u003C/code> and \u003Ccode>85812e40cf29f7103731cc6a17b101a4d640aec0\u003C/code>, respectively. (This information can be found with \u003Ccode>bits base58 --check --decode\u003C/code>).\u003C/p>\n\u003Cp>Thus, for the transaction output spending to \u003Ccode>mp6UyrvbWH3sq1WRjHnVZr23aJfuwDktZg\u003C/code>, the scriptPubkey becomes\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits script OP_DUP OP_HASH160 5e185942ab1fb90f4880c57384df78dc657a0dba OP_EQUALVERIFY OP_CHECKSIG\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">76a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac\n\u003C/code>\u003C/pre>\n\u003Cp>And for \u003Ccode>msgrvCT4DagqPAuFoqqCWqBouv43KyRors\u003C/code>,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits script OP_DUP OP_HASH160 85812e40cf29f7103731cc6a17b101a4d640aec0 OP_EQUALVERIFY OP_CHECKSIG\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">76a91485812e40cf29f7103731cc6a17b101a4d640aec088ac\n\u003C/code>\u003C/pre>\n\u003Cp>Putting it all together, and forming the pre-signature transaction data we have,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits tx -txin &#39;{&quot;txid&quot;: &quot;1c9eb55b17705ca5fc3047d9490ebd3e38422be18fa130dc2389b233767dbc65&quot;, &quot;vout&quot;: 0, &quot;scriptsig&quot;: &quot;76a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88ac&quot;}&#39; -txout &#39;{&quot;satoshis&quot;: 4000000000, &quot;scriptpubkey&quot;: &quot;76a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac&quot;}&#39; -txout &#39;{&quot;satoshis&quot;: 999999000, &quot;scriptpubkey&quot;: &quot;76a91485812e40cf29f7103731cc6a17b101a4d640aec088ac&quot;}&#39;\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000001976a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88acffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000\n\u003C/code>\u003C/pre>\n\u003Cp>Notice that the UTXO&#39;s scriptpubkey is inserted as the scriptsig for the transaction data that used for signing. Now finally, to spend the transaction input, we must sign the transaction data and re-insert the correct scriptsig. For this, we will make use of the \u003Ccode>bits sig\u003C/code> command.\u003C/p>\n\u003Ch3>Signing, and verifying signatures\u003C/h3>\n\u003Cp>With the \u003Ccode>bits sig\u003C/code> command, we can create (and verify) Bitcoin signatures.\u003C/p>\n\u003Cp>To sign the above transaction with the private key associated with the UTXO address (i.e. \u003Ccode>sender.hex\u003C/code>), we can use following command.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits sig -i sender.hex 010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000001976a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88acffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000 --sighash all\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">3045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a901\n\u003C/code>\u003C/pre>\n\u003Cp>If you would need to verify this signature with the sender&#39;s pubkey (i.e. \u003Ccode>sender.pub\u003C/code>), the following may be used.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo 02ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fc | bits sig --verify 010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000001976a91439a6b4b85e0108176524ab3b1584f5b9ac21d6da88acffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000 --signature 3045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a901\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">OK\n\u003C/code>\u003C/pre>\n\u003Cp>Now that we have the signature, we can form the final scriptsig necessary for this P2PKH UTXO. The scriptsig for a P2PKH output is \u003Ccode>&lt;signature&gt; &lt;pubkey&gt;\u003C/code>, both of which can be found above. Therefore we have,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits script 3045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a901 02ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fc\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fc\n\u003C/code>\u003C/pre>\n\u003Cp>And now, forming the final transaction\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits tx -txin &#39;{&quot;txid&quot;: &quot;1c9eb55b17705ca5fc3047d9490ebd3e38422be18fa130dc2389b233767dbc65&quot;, &quot;vout&quot;: 0, &quot;scriptsig&quot;: &quot;483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fc&quot;}&#39; -txout &#39;{&quot;satoshis&quot;: 4000000000, &quot;scriptpubkey&quot;: &quot;76a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac&quot;}&#39; -txout &#39;{&quot;satoshis&quot;: 999999000, &quot;scriptpubkey&quot;: &quot;76a91485812e40cf29f7103731cc6a17b101a4d640aec088ac&quot;}&#39;\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000006b483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fcffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000\n\u003C/code>\u003C/pre>\n\u003Cp>Finally, this transaction is ready to be broadcasted to the Bitcoin network. And we can send it using our \u003Ca href=\"#configuring-bits-with-a-local-bitcoin-core-node\">configured\u003C/a> \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> RPC node. First let&#39;s test the transaction&#39;s validity with,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits rpc testmempoolaccept &#39;[&quot;010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000006b483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fcffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000&quot;]&#39;\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">[{&#39;txid&#39;: &#39;4ecc3ff0cc54a09b71e4fe5b981bcc930a31e09dfef7f8804b7be4932b251dd2&#39;, &#39;wtxid&#39;: &#39;4ecc3ff0cc54a09b71e4fe5b981bcc930a31e09dfef7f8804b7be4932b251dd2&#39;, &#39;allowed&#39;: True, &#39;vsize&#39;: 226, &#39;fees&#39;: {&#39;base&#39;: 1e-05}}]\n\u003C/code>\u003C/pre>\n\u003Cp>And then actually send it with\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits rpc sendrawtransaction &quot;010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000006b483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fcffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000&quot;\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">4ecc3ff0cc54a09b71e4fe5b981bcc930a31e09dfef7f8804b7be4932b251dd2\n\u003C/code>\u003C/pre>\n\u003Cp>Remember, you will need to wait, at least until the transaction is mined in a block, for the transfer of funds to be reflected in the blockchain.\u003C/p>\n\u003Ch4>Decoding raw transactions\u003C/h4>\n\u003Cp>You may also \u003Cem>decode\u003C/em> this raw transaction using \u003Ccode>bits tx --decode\u003C/code>. E.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo 010000000165bc7d7633b28923dc30a18fe12b42383ebd0e49d94730fca55c70175bb59e1c000000006b483045022100f0cbe27a8f8fe3bde49abcfb15c218fd0e9afe1a69354976752cc4c3c0b11ab60220303ca69643fa29dad33868b1fc8ee1fad29b41890c0cc25f7393a610e6a2d9a9012102ed5df88a8fa1f10389b263eeae8df6456fc16f38da21d8737b9a65a246c358fcffffffff0200286bee000000001976a9145e185942ab1fb90f4880c57384df78dc657a0dba88ac18c69a3b000000001976a91485812e40cf29f7103731cc6a17b101a4d640aec088ac00000000 | bits tx --decode | jq .\n\u003C/code>\u003C/pre>\n\u003Ch3>A more convenient approach for sending funds: \u003Ccode>bits send\u003C/code>\u003C/h3>\n\u003Cp>Forming raw transactions as above, affords us great flexibility, but is a bit tedious. Therefore \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> provides the \u003Ccode>bits send\u003C/code> command, which, as opposed to \u003Ccode>bits tx\u003C/code>, provides a better user inteface, and does some of the tedious steps behind the scenes; thereby trading flexibility for convenience.\u003C/p>\n\u003Cp>The \u003Ccode>bits send\u003C/code> command integrates directly with (and thus depends on) a \u003Ca href=\"#configuring-bits-with-a-local-bitcoin-core-node\">configured\u003C/a> \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> node.\u003C/p>\n\u003Cp>Let&#39;s see how it works.\u003C/p>\n\u003Cp>Suppose we have 3.125 BTC associated with the SegWit address \u003Ccode>bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz\u003C/code> on a local regtest Bitcoin network. Let&#39;s send half of these funds to a new address, \u003Ccode>bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca\u003C/code>, and use \u003Ccode>mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c\u003C/code> as the change address.\u003C/p>\n\u003Cp>Many of the tedious steps we had to do in \u003Ca href=\"#creating-raw-transactions\">creating raw transactions\u003C/a> can now be simply expressed as the following.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits send bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca --send-fraction 0.5 --change-addr mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">010000000189592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa6150000000000ffffffff02a82b5009000000001600146b53716cc77c270471ae3dc6a048ac8904f621a5902f5009000000001976a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac00000000\n\u003C/code>\u003C/pre>\n\u003Cp>We can inspect this output by using a command seen previously, \u003Ccode>bits tx --decode\u003C/code>, i.e.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo 010000000189592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa6150000000000ffffffff02a82b5009000000001600146b53716cc77c270471ae3dc6a048ac8904f621a5902f5009000000001976a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac00000000 | bits tx --decode | jq .\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">{\n  &quot;txid&quot;: &quot;1053c3fe474b13156ad6611d5ebfaf6c500711f7742d5978ad3559d2b8beeeb3&quot;,\n  &quot;wtxid&quot;: &quot;1053c3fe474b13156ad6611d5ebfaf6c500711f7742d5978ad3559d2b8beeeb3&quot;,\n  &quot;version&quot;: 1,\n  &quot;txins&quot;: [\n    {\n      &quot;txid&quot;: &quot;89592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa615&quot;,\n      &quot;vout&quot;: 0,\n      &quot;scriptsig&quot;: &quot;&quot;,\n      &quot;sequence&quot;: &quot;ffffffff&quot;\n    }\n  ],\n  &quot;txouts&quot;: [\n    {\n      &quot;value&quot;: 156249000,\n      &quot;scriptpubkey&quot;: &quot;00146b53716cc77c270471ae3dc6a048ac8904f621a5&quot;\n    },\n    {\n      &quot;value&quot;: 156250000,\n      &quot;scriptpubkey&quot;: &quot;76a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac&quot;\n    }\n  ],\n  &quot;locktime&quot;: 0\n}\n\u003C/code>\u003C/pre>\n\u003Cp>By inspecting the output above, we see 156249000 satoshis in a txout associated with a scriptpubkey indicating a payment to the \u003Ccode>bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca\u003C/code> address we used above. This corresponds to half the original amount associated with the sender address of \u003Ccode>bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz\u003C/code>, minus the miner fee (which defaults to 1000 satoshis but may be specified by using the \u003Ccode>--miner-fee\u003C/code> option). We also see the rest of the satoshis being associated in a txout with a scriptpubkey indicating a payment to to our change address of \u003Ccode>mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c\u003C/code>.\u003C/p>\n\u003Cp>However, this raw transaction has not been signed yet. We can see that from the above output by noticing that there is no witness data, which is needed for spenditure from the SegWit sender address, and correspondingly the wtxid is equal to the txid. But, we can do so easily with the \u003Ccode>bits send\u003C/code> command, by provided the private key(s) necessary for spenditure, in \u003Cem>extended\u003C/em> \u003Ca href=\"https://en.bitcoin.it/wiki/Wallet_import_format\">WIF\u003C/a> format. The extended WIF encoded private key can be created with the \u003Ccode>bits wif\u003C/code> command.\u003C/p>\n\u003Ch3>Encode (or decode) a private key in extended WIF format\u003C/h3>\n\u003Cp>Building upon WIF and code seen in the \u003Ca href=\"https://github.com/spesmilo/electrum/blob/4.4.0/electrum/bitcoin.py#L618-L625\">electrum wallet codebase\u003C/a>, \u003Cem>extended\u003C/em> WIF, allows for encoding a private key with additional data indicating not only its corresponding address type, but also the additional data necessary for spenditure (i.e. the data needed for creating an appropriate scriptsig, such as the redeem script for a P2SH address, for example).\u003C/p>\n\u003Cp>To provide some background, a standard WIF encoded key is defined as the following, encoded in base58check.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-text\">network version byte + private key + optional 0x01 byte denoting a compressed pubkey\n\u003C/code>\u003C/pre>\n\u003Cp>\u003Cem>Extended\u003C/em> WIF for the purposes here is defined as the following data structure, encoded in base58check.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-text\">(network version byte + address type offset) + private key + (data)\n\u003C/code>\u003C/pre>\n\u003Cp>To summarize, extended WIF allows us to provide extra information on the specific address type the private key shall correspond to, and the arbitrary data needed to spend it, while being backwards compatible with standard WIF.\u003C/p>\n\u003Cp>The \u003Ccode>bits wif\u003C/code> command makes this encoding task easier for us. To encode the private key associated with the sender address used above, we may use the following, for example.\u003C/p>\n\u003Cp>Assuming the private key is stored in hexadecimal string format in a file named \u003Ccode>sender_addr.hex\u003C/code>, we have,\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits wif -i sender_addr.hex -T p2wpkh -P\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">94oeEPncUHF7hrXPx7bdbSPrar8tx8bUFNihAg6qr6NAN8Txxrb\n\u003C/code>\u003C/pre>\n\u003Cp>We supplied the \u003Ccode>-T\u003C/code> option (\u003Ccode>--addr-type\u003C/code>) to denote a \u003Ccode>p2wpkh\u003C/code> address type and omitted the \u003Ccode>-D\u003C/code> option (\u003Ccode>--data\u003C/code>) for optional data, since a compressed pubkey is implied for SegWit p2wpkh addresses. Information and help on the necessary data as well as the various supported address types for extended WIF, can be seen with the \u003Ccode>bits wif -h\u003C/code> command.\u003C/p>\n\u003Cp>We can also review the encoding, by performing a \u003Cem>decode\u003C/em> operation with the following.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo -n 94oeEPncUHF7hrXPx7bdbSPrar8tx8bUFNihAg6qr6NAN8Txxrb | bits wif --decode | jq .\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">{\n  &quot;version&quot;: &quot;f0&quot;,\n  &quot;network&quot;: &quot;testnet&quot;,\n  &quot;addr_type&quot;: &quot;p2wpkh&quot;,\n  &quot;key&quot;: &quot;a7fb90f08460ae7cac8ddb29df999e47e942809a48f353d5fcfc84845d759904&quot;,\n  &quot;data&quot;: &quot;&quot;\n}\n\u003C/code>\u003C/pre>\n\u003Cp>Here we see the decoded address as a JSON structure. We see a version of hex \u003Ccode>f0\u003C/code> indicating the \u003Ccode>ef\u003C/code> testnet/regtest network version byte plus address offset of \u003Ccode>01\u003C/code> for a P2WPKH address. We also see that information being provided by the \u003Ccode>network\u003C/code> and \u003Ccode>addr_type\u003C/code> keys, respectively. Finally we see the decoded private key value in hexadecimal string format, as well as the empty data key value, since no further data was appended.\u003C/p>\n\u003Cp>Now, we can take this key back to our \u003Ccode>bits send\u003C/code> command we used previously to sign the transaction for spenditure from the sender address of \u003Ccode>bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz\u003C/code>.\u003C/p>\n\u003Ch3>Signing the transaction with \u003Ccode>bits send\u003C/code>\u003C/h3>\n\u003Cp>Now, we simply take the command we used previously, but also leverage the \u003Ccode>--sighash\u003C/code> option to specify the SIGHASH flag and denote a signing operation is to occur, and provide the WIF key(s) necessary for spenditure via the input, i.e.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo -n 94oeEPncUHF7hrXPx7bdbSPrar8tx8bUFNihAg6qr6NAN8Txxrb | bits send bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca --send-fraction 0.5 --change-addr mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c --sighash all\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">0100000000010189592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa6150000000000ffffffff02a82b5009000000001600146b53716cc77c270471ae3dc6a048ac8904f621a5902f5009000000001976a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac0247304402202f14ed3b68d8a97faf5c7f176f55d8610d27adf85927d213de88f562d821d2eb02203c04f9b9280038f34de89990852c3b54b94174154be5b01621e9dc5a5c4488d201210365a02c1e0ca4e10aa8ff5283ac0476077c503a440699212744ded7235ba5f87500000000\n\u003C/code>\u003C/pre>\n\u003Cp>Before sending, we can inspect the transaction with \u003Ccode>bits tx --decode\u003C/code>, i.e.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">echo 0100000000010189592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa6150000000000ffffffff02a82b5009000000001600146b53716cc77c270471ae3dc6a048ac8904f621a5902f5009000000001976a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac0247304402202f14ed3b68d8a97faf5c7f176f55d8610d27adf85927d213de88f562d821d2eb02203c04f9b9280038f34de89990852c3b54b94174154be5b01621e9dc5a5c4488d201210365a02c1e0ca4e10aa8ff5283ac0476077c503a440699212744ded7235ba5f87500000000 | bits tx --decode | jq .\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">{\n  &quot;txid&quot;: &quot;1053c3fe474b13156ad6611d5ebfaf6c500711f7742d5978ad3559d2b8beeeb3&quot;,\n  &quot;wtxid&quot;: &quot;30fee44633756231d2bf767b91ca6ad1109538aa5dbbb5e6f3b52cc0dac3aa32&quot;,\n  &quot;version&quot;: 1,\n  &quot;txins&quot;: [\n    {\n      &quot;txid&quot;: &quot;89592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa615&quot;,\n      &quot;vout&quot;: 0,\n      &quot;scriptsig&quot;: &quot;&quot;,\n      &quot;sequence&quot;: &quot;ffffffff&quot;\n    }\n  ],\n  &quot;txouts&quot;: [\n    {\n      &quot;value&quot;: 156249000,\n      &quot;scriptpubkey&quot;: &quot;00146b53716cc77c270471ae3dc6a048ac8904f621a5&quot;\n    },\n    {\n      &quot;value&quot;: 156250000,\n      &quot;scriptpubkey&quot;: &quot;76a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac&quot;\n    }\n  ],\n  &quot;witnesses&quot;: [\n    [\n      &quot;304402202f14ed3b68d8a97faf5c7f176f55d8610d27adf85927d213de88f562d821d2eb02203c04f9b9280038f34de89990852c3b54b94174154be5b01621e9dc5a5c4488d201&quot;,\n      &quot;0365a02c1e0ca4e10aa8ff5283ac0476077c503a440699212744ded7235ba5f875&quot;\n    ]\n  ],\n  &quot;locktime&quot;: 0\n}\n\u003C/code>\u003C/pre>\n\u003Cp>We now see the necessary signature data via the witness. Finally, we can again leverage our \u003Ca href=\"#configuring-bits-with-a-local-bitcoin-core-node\">configured\u003C/a> \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> RPC node to send the raw transaction, e.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits rpc sendrawtransaction &quot;0100000000010189592b942d94a2265c4c986560363b5cf672fd9c6b8b5acc212759e436efa6150000000000ffffffff02a82b5009000000001600146b53716cc77c270471ae3dc6a048ac8904f621a5902f5009000000001976a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac0247304402202f14ed3b68d8a97faf5c7f176f55d8610d27adf85927d213de88f562d821d2eb02203c04f9b9280038f34de89990852c3b54b94174154be5b01621e9dc5a5c4488d201210365a02c1e0ca4e10aa8ff5283ac0476077c503a440699212744ded7235ba5f87500000000&quot;\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">b3eebeb8d25935ad78592d74f71107506cafbf5e1d61d66a15134b47fec35310\n\u003C/code>\u003C/pre>\n\u003Cp>Again, remember that this transaction must be mined in a block before we can view the fund transfer on the blockchain, (which offers us a nice segway to some of the last subcommands we will demo in this blog) but it should now be clear how \u003Ccode>bits send\u003C/code> can provide an easier and more convenient method for sending funds.\u003C/p>\n\u003Ch3>Mining blocks\u003C/h3>\n\u003Cp>As stated just above, the raw transaction we just sent via our \u003Ca href=\"#configuring-bits-with-a-local-bitcoin-core-node\">configured\u003C/a> \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> RPC connection won&#39;t be reflected in the blockchain until it is mined. For mainnet, this will happen by some miner on the network at an average rate of every 10 minutes. However, the \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a> CLI actually provides the \u003Ccode>bits mine\u003C/code> command to mine blocks, which also depends on a locally configured Bitcoin Core node. This may take a \u003Cem>long\u003C/em> time in practice for mainnet, but for our demonstration purposes on \u003Cem>regtest\u003C/em>, this command can be used to mine blocks and receive block rewards quickly. For example, to include the raw transaction we sent above (which is now part of the mempool) in a block, and receive the reward to a new address, e.g. \u003Ccode>mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ\u003C/code>, we can use the following.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits mine --limit 1 --recv-addr mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">1 blocks mined. Reward sent to mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ\n\u003C/code>\u003C/pre>\n\u003Cp>The \u003Ccode>--limit\u003C/code> option is used to only mine the indicated number of blocks. If this option is omitted the \u003Ccode>bits mine\u003C/code> command will mine indefinitely. Also, \u003Ccode>--recv-addr\u003C/code> is used to indicate the address that the block reward shall be sent to.\u003C/p>\n\u003Cp>Now with the previous transaction mined in a block, the following command can show us the respective amounts now allocated to the various addresses used in this demonstration.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits rpc scantxoutset start &#39;[&quot;addr(bcrt1quzz3xxt2p0488hvlfelj78dq2pgcsjkd3auhwz)&quot;, &quot;addr(bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca)&quot;, &quot;addr(mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c)&quot;, &quot;addr(mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ)&quot;]&#39; | jq .\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">{\n  &quot;success&quot;: true,\n  &quot;txouts&quot;: 830,\n  &quot;height&quot;: 828,\n  &quot;bestblock&quot;: &quot;1f0f9cfb4360b649dbe4581e369dd0b80e3e7177a560f4f73e5c3873ba6f996f&quot;,\n  &quot;unspents&quot;: [\n    {\n      &quot;txid&quot;: &quot;b3eebeb8d25935ad78592d74f71107506cafbf5e1d61d66a15134b47fec35310&quot;,\n      &quot;vout&quot;: 0,\n      &quot;scriptPubKey&quot;: &quot;00146b53716cc77c270471ae3dc6a048ac8904f621a5&quot;,\n      &quot;desc&quot;: &quot;addr(bcrt1qddfhzmx80snsgudw8hr2qj9v3yz0vgd9wj5wca)#qq7tl9lw&quot;,\n      &quot;amount&quot;: 1.56249,\n      &quot;height&quot;: 828\n    },\n    {\n      &quot;txid&quot;: &quot;b3eebeb8d25935ad78592d74f71107506cafbf5e1d61d66a15134b47fec35310&quot;,\n      &quot;vout&quot;: 1,\n      &quot;scriptPubKey&quot;: &quot;76a9145e26bd0264f1a2451c552e313ad94b7127c7a76488ac&quot;,\n      &quot;desc&quot;: &quot;addr(mp6nDfuUJWV1pNdcxNQtbU29eg3fJ6eK4c)#nxeam3zm&quot;,\n      &quot;amount&quot;: 1.5625,\n      &quot;height&quot;: 828\n    },\n    {\n      &quot;txid&quot;: &quot;53b49c2022496267c0f962422b2a4fc27d09f88472a5536dd5640a36a2e5df63&quot;,\n      &quot;vout&quot;: 0,\n      &quot;scriptPubKey&quot;: &quot;76a914a557ee47fee5eb85822017b26c03b9d1884a19e088ac&quot;,\n      &quot;desc&quot;: &quot;addr(mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ)#4j85pt9g&quot;,\n      &quot;amount&quot;: 1.5625,\n      &quot;height&quot;: 828\n    }\n  ],\n  &quot;total_amount&quot;: 4.68749\n}\n\u003C/code>\u003C/pre>\n\u003Cp>Note that per consensus rules, the block reward will remain unavailable for spenditure for 100 blocks; so to make the funds now associated with \u003Ccode>mvbD8F7cuoQcUcTfnLU72rMtB35P6wAHBJ\u003C/code> immediately available, we can mine 100 blocks, e.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits mine --limit 100 --recv-addr &quot;&quot;\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">100 blocks mined. Reward sent to\n\u003C/code>\u003C/pre>\n\u003Cp>Note that we provided an empty \u003Ccode>--recv-addr\u003C/code> for demo purposes since we do not care about the block reward in this instance on regtest. This is not recommended for production purposes on mainnet! ü§ë\u003C/p>\n\u003Ch3>Closing bits\u003C/h3>\n\u003Cp>That about wraps it up for this blog post, but before we go, there are a couple more subcommands I&#39;d like to explain.\u003C/p>\n\u003Cp>Though unsupported (nor functionl nor advised üòÖ), there does exist a \u003Ccode>bits p2p\u003C/code> command , which intends to eventually implement a functional native full node for \u003Ca href=\"https://github.com/jtraub91/bits\">bits\u003C/a>, which would thereby deprecate support for \u003Ca href=\"#configuring-bits-with-a-local-bitcoin-core-node\">configuring\u003C/a> a \u003Ca href=\"https://github.com/bitcoin/bitcoin\">Bitcoin Core\u003C/a> RPC connection. Exposing this subcommand is only to show users what is in the codebase today, and to help to illustrate what is planned for future. Play around or hack on it, but don&#39;t expect it to do anything too useful at present.\u003C/p>\n\u003Cp>Finally, the last subcommand I will mention is the \u003Ccode>bits blockchain\u003C/code> command. Again, this command is planned to be able to explore and retrieve blockchain data, and will depend on a functioning \u003Ccode>bits p2p\u003C/code> full node. In the meantime it supports \u003Cem>decoding\u003C/em> raw blocks (via \u003Ccode>bits blockchain --decode\u003C/code>), which can be useful for debugging. Other than that, it currently supports retrieving only the hard-coded genesis block of the Bitcoin blockchain, at the block height of 0, e.g.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits blockchain 0\n\u003C/code>\u003C/pre>\n\u003Cp>Output:\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">01000000000000000000000000000000000000000000000000000000000000000000000001000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac0000000029ab5f49ffff001d1dac2b7c0101000000010000000000000000000000000000000000000000000000000000000000000000ffffffff4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73ffffffff0100f2052a01000000434104678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5fac00000000\n\u003C/code>\u003C/pre>\n\u003Cp>Like many \u003Ccode>bits\u003C/code> subcommands, the output can be specified as raw binary, for which may be interesting to view, as this output contains some notable historical information üòâ.\u003C/p>\n\u003Cpre>\u003Ccode class=\"language-bash\">bits blockchain 0 -0\n\u003C/code>\u003C/pre>\n\u003Cp>That concludes this post! Thanks for bearing with me üôè I hope you find this cli tool and library to be useful. Please feel free to reach out for questions or to just say hi üëã Till next time ‚úåÔ∏è üòé ‚ù§Ô∏è\u003C/p>\n\u003Ch3>Citations\u003C/h3>\n\u003Col>\n\u003Cli>\u003Ca href=\"https://linux.die.net/man/1/xxd\">xxd man page\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://www.secg.org/sec2-v2.pdf\">SEC 2: Recommended Elliptic Curve Domain Parameters\u003C/a>\u003C/li>\n\u003C/ol>\n",title:"Introducing bits",date:new Date(1684800000000),author:"jtraub91"},"uses":{"params":["slug"]}}],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
